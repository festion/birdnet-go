
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>processor: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/tphakala/birdnet-go/internal/analysis/processor/actions.go (0.0%)</option>
				
				<option value="file1">github.com/tphakala/birdnet-go/internal/analysis/processor/dogbarkfilter.go (0.0%)</option>
				
				<option value="file2">github.com/tphakala/birdnet-go/internal/analysis/processor/dynamic_threshold.go (0.0%)</option>
				
				<option value="file3">github.com/tphakala/birdnet-go/internal/analysis/processor/eventtracker.go (0.0%)</option>
				
				<option value="file4">github.com/tphakala/birdnet-go/internal/analysis/processor/execute.go (0.0%)</option>
				
				<option value="file5">github.com/tphakala/birdnet-go/internal/analysis/processor/jobqueue_adapter.go (0.0%)</option>
				
				<option value="file6">github.com/tphakala/birdnet-go/internal/analysis/processor/log_deduplicator.go (0.0%)</option>
				
				<option value="file7">github.com/tphakala/birdnet-go/internal/analysis/processor/logger.go (33.3%)</option>
				
				<option value="file8">github.com/tphakala/birdnet-go/internal/analysis/processor/mqtt.go (0.0%)</option>
				
				<option value="file9">github.com/tphakala/birdnet-go/internal/analysis/processor/new_species_tracker.go (46.4%)</option>
				
				<option value="file10">github.com/tphakala/birdnet-go/internal/analysis/processor/processor.go (0.0%)</option>
				
				<option value="file11">github.com/tphakala/birdnet-go/internal/analysis/processor/test_helpers.go (77.8%)</option>
				
				<option value="file12">github.com/tphakala/birdnet-go/internal/analysis/processor/workers.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// processor/actions.go

package processor

import (
        "context"
        "encoding/json"
        "fmt"
        "log"
        "os"
        "path/filepath"
        "strings"
        "sync"
        "time"

        "github.com/tphakala/birdnet-go/internal/analysis/jobqueue"
        "github.com/tphakala/birdnet-go/internal/birdnet"
        "github.com/tphakala/birdnet-go/internal/birdweather"
        "github.com/tphakala/birdnet-go/internal/conf"
        "github.com/tphakala/birdnet-go/internal/datastore"
        "github.com/tphakala/birdnet-go/internal/errors"
        "github.com/tphakala/birdnet-go/internal/events"
        "github.com/tphakala/birdnet-go/internal/imageprovider"
        "github.com/tphakala/birdnet-go/internal/mqtt"
        "github.com/tphakala/birdnet-go/internal/myaudio"
        "github.com/tphakala/birdnet-go/internal/notification"
        "github.com/tphakala/birdnet-go/internal/observation"
)

// Timeout and interval constants
const (
        // SSEDatabaseIDTimeout is the maximum time to wait for database ID assignment
        SSEDatabaseIDTimeout = 10 * time.Second
        
        // SSEDatabaseCheckInterval is how often to check for database ID
        SSEDatabaseCheckInterval = 200 * time.Millisecond
        
        // SSEAudioFileTimeout is the maximum time to wait for audio file to be written
        SSEAudioFileTimeout = 5 * time.Second
        
        // SSEAudioCheckInterval is how often to check for audio file
        SSEAudioCheckInterval = 100 * time.Millisecond
        
        // MinAudioFileSize is the minimum size in bytes for a valid audio file
        // Typed as int64 to match os.FileInfo.Size() return type
        MinAudioFileSize int64 = 1024
        
        // MQTTPublishTimeout is the timeout for MQTT publish operations
        MQTTPublishTimeout = 10 * time.Second
        
        // AudioSegmentDuration is the duration of audio segments to capture
        AudioSegmentDuration = 15 * time.Second
        
        // DatabaseSearchLimit is the maximum number of results when searching for notes
        DatabaseSearchLimit = 10
        
        // CompositeActionTimeout is the default timeout for each action in a composite action
        // This is generous to accommodate slow hardware (e.g., Raspberry Pi with SD cards)
        CompositeActionTimeout = 30 * time.Second
        
        // ExecuteCommandTimeout is the timeout for external command execution
        ExecuteCommandTimeout = 5 * time.Minute
)

// Action is the base interface for all actions that can be executed
type Action interface {
        Execute(data interface{}) error
        GetDescription() string
}

// ContextAction is an enhanced action interface that supports context-aware execution
// This allows for proper cancellation and timeout propagation
type ContextAction interface {
        Action
        ExecuteContext(ctx context.Context, data interface{}) error
}

type LogAction struct {
        Settings     *conf.Settings
        Note         datastore.Note
        EventTracker *EventTracker
        Description  string
        mu           sync.Mutex // Protect concurrent access to Note
}

type DatabaseAction struct {
        Settings          *conf.Settings
        Ds                datastore.Interface
        Note              datastore.Note
        Results           []datastore.Results
        EventTracker      *EventTracker
        NewSpeciesTracker *NewSpeciesTracker // Add reference to new species tracker
        processor         *Processor         // Add reference to processor for source name resolution
        Description       string
        mu                sync.Mutex // Protect concurrent access to Note and Results
}

type SaveAudioAction struct {
        Settings     *conf.Settings
        ClipName     string
        pcmData      []byte
        EventTracker *EventTracker
        Description  string
        mu           sync.Mutex // Protect concurrent access to pcmData
}

type BirdWeatherAction struct {
        Settings     *conf.Settings
        Note         datastore.Note
        pcmData      []byte
        BwClient     *birdweather.BwClient
        EventTracker *EventTracker
        RetryConfig  jobqueue.RetryConfig // Configuration for retry behavior
        Description  string
        mu           sync.Mutex // Protect concurrent access to Note and pcmData
}

type MqttAction struct {
        Settings       *conf.Settings
        Note           datastore.Note
        BirdImageCache *imageprovider.BirdImageCache
        MqttClient     mqtt.Client
        EventTracker   *EventTracker
        RetryConfig    jobqueue.RetryConfig // Configuration for retry behavior
        Description    string
        mu             sync.Mutex // Protect concurrent access to Note
}

type UpdateRangeFilterAction struct {
        Bn          *birdnet.BirdNET
        Settings    *conf.Settings
        Description string
        mu          sync.Mutex // Protect concurrent access to Settings
}

type SSEAction struct {
        Settings       *conf.Settings
        Note           datastore.Note
        BirdImageCache *imageprovider.BirdImageCache
        EventTracker   *EventTracker
        RetryConfig    jobqueue.RetryConfig // Configuration for retry behavior
        Description    string
        mu             sync.Mutex // Protect concurrent access to Note
        // SSEBroadcaster is a function that broadcasts detection data
        // This allows the action to be independent of the specific API implementation
        SSEBroadcaster func(note *datastore.Note, birdImage *imageprovider.BirdImage) error
        // Datastore interface for querying the database to get the assigned ID
        Ds datastore.Interface
}

// CompositeAction executes multiple actions sequentially, ensuring proper dependency management.
//
// This action type was introduced to fix a critical race condition between DatabaseAction 
// and SSEAction (GitHub issue #1158). The SSEAction depends on DatabaseAction completing 
// first to ensure database IDs are assigned before SSE broadcasts occur.
//
// Key Features:
//   - Sequential execution: Actions execute in order, each waiting for the previous to complete
//   - Configurable timeout: Per-action timeout can be overridden (default: 30 seconds)
//   - Context support: Actions implementing ContextAction get proper context propagation
//   - Panic recovery: Panics in individual actions are caught and converted to errors
//   - Thread-safe: Mutex protects the Actions slice during access
//   - Nil-safe: Handles nil actions and empty action lists gracefully
//
// Usage:
//
//        timeout := 45 * time.Second
//        composite := &amp;CompositeAction{
//            Actions: []Action{databaseAction, sseAction},
//            Description: "Save to database then broadcast",
//            Timeout: &amp;timeout,  // Optional: override default timeout
//        }
//        err := composite.Execute(data)
//
// This pattern ensures that dependent actions execute in the correct order, preventing
// timeout errors like "database ID not assigned after 10s" that occur when actions
// execute concurrently on resource-constrained hardware.
type CompositeAction struct {
        Actions     []Action       // Actions to execute in sequence
        Description string         // Human-readable description
        Timeout     *time.Duration // Optional: per-action timeout override (nil = use default)
        mu          sync.Mutex     // Protects concurrent access to Actions
}

// GetDescription returns a human-readable description of the LogAction
func (a *LogAction) GetDescription() string <span class="cov0" title="0">{
        if a.Description != "" </span><span class="cov0" title="0">{
                return a.Description
        }</span>
        <span class="cov0" title="0">return "Log bird detection to file"</span>
}

// GetDescription returns a human-readable description of the DatabaseAction
func (a *DatabaseAction) GetDescription() string <span class="cov0" title="0">{
        if a.Description != "" </span><span class="cov0" title="0">{
                return a.Description
        }</span>
        <span class="cov0" title="0">return "Save bird detection to database"</span>
}

// GetDescription returns a human-readable description of the SaveAudioAction
func (a *SaveAudioAction) GetDescription() string <span class="cov0" title="0">{
        if a.Description != "" </span><span class="cov0" title="0">{
                return a.Description
        }</span>
        <span class="cov0" title="0">return "Save audio clip to file"</span>
}

// GetDescription returns a human-readable description of the BirdWeatherAction
func (a *BirdWeatherAction) GetDescription() string <span class="cov0" title="0">{
        if a.Description != "" </span><span class="cov0" title="0">{
                return a.Description
        }</span>
        <span class="cov0" title="0">return "Upload detection to BirdWeather"</span>
}

// GetDescription returns a human-readable description of the MqttAction
func (a *MqttAction) GetDescription() string <span class="cov0" title="0">{
        if a.Description != "" </span><span class="cov0" title="0">{
                return a.Description
        }</span>
        <span class="cov0" title="0">return "Publish detection to MQTT"</span>
}

// GetDescription returns a human-readable description of the UpdateRangeFilterAction
func (a *UpdateRangeFilterAction) GetDescription() string <span class="cov0" title="0">{
        if a.Description != "" </span><span class="cov0" title="0">{
                return a.Description
        }</span>
        <span class="cov0" title="0">return "Update BirdNET range filter"</span>
}

// GetDescription returns a human-readable description of the SSEAction
func (a *SSEAction) GetDescription() string <span class="cov0" title="0">{
        if a.Description != "" </span><span class="cov0" title="0">{
                return a.Description
        }</span>
        <span class="cov0" title="0">return "Broadcast detection via Server-Sent Events"</span>
}

// GetDescription returns a human-readable description of the CompositeAction
func (a *CompositeAction) GetDescription() string <span class="cov0" title="0">{
        if a.Description != "" </span><span class="cov0" title="0">{
                return a.Description
        }</span>
        <span class="cov0" title="0">return "Composite action (sequential execution)"</span>
}

// Execute runs all actions sequentially, stopping on first error
// This method is designed to prevent deadlocks and handle timeouts properly
func (a *CompositeAction) Execute(data interface{}) error <span class="cov0" title="0">{
        // Handle nil or empty actions gracefully
        if a == nil || a.Actions == nil || len(a.Actions) == 0 </span><span class="cov0" title="0">{
                return nil // Nothing to execute
        }</span>

        // Only lock while accessing the Actions slice, not during execution
        <span class="cov0" title="0">a.mu.Lock()
        actions := make([]Action, len(a.Actions))
        copy(actions, a.Actions)
        a.mu.Unlock()

        // Count non-nil actions for accurate progress reporting
        nonNilCount := 0
        for _, action := range actions </span><span class="cov0" title="0">{
                if action != nil </span><span class="cov0" title="0">{
                        nonNilCount++
                }</span>
        }

        <span class="cov0" title="0">if nonNilCount == 0 </span><span class="cov0" title="0">{
                return nil // All actions are nil
        }</span>

        // Execute each action in order without holding the mutex
        <span class="cov0" title="0">currentStep := 0
        for _, action := range actions </span><span class="cov0" title="0">{
                if action == nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">currentStep++

                // Add panic recovery for each action to prevent crashes
                err := a.executeActionWithRecovery(action, data, currentStep, nonNilCount)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// executeActionWithRecovery executes a single action with panic recovery and proper context handling
func (a *CompositeAction) executeActionWithRecovery(action Action, data interface{}, step, total int) error <span class="cov0" title="0">{
        // Determine the timeout to use
        timeout := CompositeActionTimeout
        if a.Timeout != nil </span><span class="cov0" title="0">{
                timeout = *a.Timeout
        }</span>

        // Create context with timeout for proper cancellation
        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(context.Background(), timeout)
        defer cancel() // Ensure cancel is always called to prevent context leak

        // Use a channel to capture the result
        type result struct {
                err error
        }
        resultChan := make(chan result, 1)

        // Check if action supports context-aware execution
        if contextAction, ok := action.(ContextAction); ok </span><span class="cov0" title="0">{
                // Use context-aware execution path
                go func() </span><span class="cov0" title="0">{
                        // Recover from panics to prevent goroutine crashes
                        defer func() </span><span class="cov0" title="0">{
                                if r := recover(); r != nil </span><span class="cov0" title="0">{
                                        panicErr := errors.Newf("action panicked: %v", r).
                                                Component("analysis.processor").
                                                Category(errors.CategoryProcessing).
                                                Context("action_type", fmt.Sprintf("%T", action)).
                                                Context("action_description", action.GetDescription()).
                                                Context("panic_value", fmt.Sprintf("%v", r)).
                                                Context("step", step).
                                                Context("total_steps", total).
                                                Build()
                                        select </span>{
                                        case resultChan &lt;- result{err: panicErr}:<span class="cov0" title="0"></span>
                                        case &lt;-ctx.Done():<span class="cov0" title="0"></span>
                                                // Context cancelled, exit gracefully
                                        }
                                }
                        }()

                        // Execute the action with context
                        <span class="cov0" title="0">err := contextAction.ExecuteContext(ctx, data)
                        select </span>{
                        case resultChan &lt;- result{err: err}:<span class="cov0" title="0"></span>
                        case &lt;-ctx.Done():<span class="cov0" title="0"></span>
                                // Context cancelled, exit gracefully
                        }
                }()
        } else<span class="cov0" title="0"> {
                // Fall back to legacy execution with goroutine management
                go func() </span><span class="cov0" title="0">{
                        // Recover from panics to prevent goroutine crashes
                        defer func() </span><span class="cov0" title="0">{
                                if r := recover(); r != nil </span><span class="cov0" title="0">{
                                        panicErr := errors.Newf("action panicked: %v", r).
                                                Component("analysis.processor").
                                                Category(errors.CategoryProcessing).
                                                Context("action_type", fmt.Sprintf("%T", action)).
                                                Context("action_description", action.GetDescription()).
                                                Context("panic_value", fmt.Sprintf("%v", r)).
                                                Context("step", step).
                                                Context("total_steps", total).
                                                Build()
                                        select </span>{
                                        case resultChan &lt;- result{err: panicErr}:<span class="cov0" title="0"></span>
                                        case &lt;-ctx.Done():<span class="cov0" title="0"></span>
                                                // Context cancelled, exit gracefully
                                        }
                                }
                        }()

                        // Create a channel to signal completion
                        <span class="cov0" title="0">done := make(chan struct{})
                        var execErr error

                        // Execute the action in a separate goroutine
                        go func() </span><span class="cov0" title="0">{
                                defer close(done)
                                // Add panic recovery for the execution goroutine
                                defer func() </span><span class="cov0" title="0">{
                                        if r := recover(); r != nil </span><span class="cov0" title="0">{
                                                // Convert panic to error
                                                execErr = errors.Newf("action panicked: %v", r).
                                                        Component("analysis.processor").
                                                        Category(errors.CategoryProcessing).
                                                        Context("action_type", fmt.Sprintf("%T", action)).
                                                        Context("action_description", action.GetDescription()).
                                                        Context("panic_value", fmt.Sprintf("%v", r)).
                                                        Context("step", step).
                                                        Context("total_steps", total).
                                                        Build()
                                        }</span>
                                }()
                                <span class="cov0" title="0">execErr = action.Execute(data)</span>
                        }()

                        // Wait for either completion or context cancellation
                        <span class="cov0" title="0">select </span>{
                        case &lt;-done:<span class="cov0" title="0">
                                // Action completed, send result
                                select </span>{
                                case resultChan &lt;- result{err: execErr}:<span class="cov0" title="0"></span>
                                case &lt;-ctx.Done():<span class="cov0" title="0"></span>
                                        // Context cancelled while sending result
                                }
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                // Context cancelled/timed out
                                // The Execute goroutine will continue but we won't wait for it
                                // This prevents blocking but the goroutine will complete eventually
                                select </span>{
                                case resultChan &lt;- result{err: ctx.Err()}:<span class="cov0" title="0"></span>
                                default:<span class="cov0" title="0"></span>
                                }
                        }
                }()
        }

        // Wait for result or timeout
        <span class="cov0" title="0">select </span>{
        case res := &lt;-resultChan:<span class="cov0" title="0">
                if res.err != nil </span><span class="cov0" title="0">{
                        // Check if it was a context error
                        if errors.Is(res.err, context.DeadlineExceeded) </span><span class="cov0" title="0">{
                                timeoutErr := errors.Newf("action timed out after %v", timeout).
                                        Component("analysis.processor").
                                        Category(errors.CategoryTimeout).
                                        Context("action_type", fmt.Sprintf("%T", action)).
                                        Context("action_description", action.GetDescription()).
                                        Context("timeout_seconds", timeout.Seconds()).
                                        Context("step", step).
                                        Context("total_steps", total).
                                        Build()
                                GetLogger().Error("Composite action timed out",
                                        "component", "analysis.processor.actions",
                                        "step", step,
                                        "total_steps", total,
                                        "action_description", action.GetDescription(),
                                        "timeout_seconds", timeout.Seconds(),
                                        "operation", "composite_action_timeout")
                                return timeoutErr
                        }</span>
                        // Log other errors
                        <span class="cov0" title="0">GetLogger().Error("Composite action failed",
                                "component", "analysis.processor.actions",
                                "step", step,
                                "total_steps", total,
                                "action_description", action.GetDescription(),
                                "error", res.err,
                                "operation", "composite_action_execute")
                        return res.err</span>
                }
                <span class="cov0" title="0">return nil</span>
        case &lt;-ctx.Done():<span class="cov0" title="0">
                // Context timeout or cancellation
                timeoutErr := errors.Newf("action timed out after %v", timeout).
                        Component("analysis.processor").
                        Category(errors.CategoryTimeout).
                        Context("action_type", fmt.Sprintf("%T", action)).
                        Context("action_description", action.GetDescription()).
                        Context("timeout_seconds", timeout.Seconds()).
                        Context("step", step).
                        Context("total_steps", total).
                        Build()
                GetLogger().Error("Composite action timed out",
                        "component", "analysis.processor.actions",
                        "step", step,
                        "total_steps", total,
                        "action_description", action.GetDescription(),
                        "timeout_seconds", timeout.Seconds(),
                        "operation", "composite_action_context_timeout")
                return timeoutErr</span>
        }
}

// Execute logs the note to the chag log file
func (a *LogAction) Execute(data interface{}) error <span class="cov0" title="0">{
        a.mu.Lock()
        defer a.mu.Unlock()

        species := strings.ToLower(a.Note.CommonName)

        // Check if the event should be handled for this species
        if !a.EventTracker.TrackEvent(species, LogToFile) </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Log note to file
        <span class="cov0" title="0">if err := observation.LogNoteToFile(a.Settings, &amp;a.Note); err != nil </span><span class="cov0" title="0">{
                // If an error occurs when logging to a file, wrap and return the error.
                // Add structured logging
                GetLogger().Error("Failed to log note to file",
                        "component", "analysis.processor.actions",
                        "error", err,
                        "species", a.Note.CommonName,
                        "confidence", a.Note.Confidence,
                        "clip_name", a.Note.ClipName,
                        "operation", "log_to_file")
                log.Printf("❌ Failed to log note to file")
        }</span>
        // Add structured logging for console output
        <span class="cov0" title="0">GetLogger().Info("Detection logged",
                "component", "analysis.processor.actions",
                "species", a.Note.CommonName,
                "confidence", a.Note.Confidence,
                "time", a.Note.Time,
                "operation", "console_output")
        fmt.Printf("%s %s %.2f\n", a.Note.Time, a.Note.CommonName, a.Note.Confidence)

        return nil</span>
}

// Execute saves the note to the database
func (a *DatabaseAction) Execute(data interface{}) error <span class="cov0" title="0">{
        a.mu.Lock()
        defer a.mu.Unlock()

        species := strings.ToLower(a.Note.CommonName)

        // Check event frequency
        if !a.EventTracker.TrackEvent(species, DatabaseSave) </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Check if this is a new species and update atomically to prevent race conditions
        <span class="cov0" title="0">var isNewSpecies bool
        var daysSinceFirstSeen int
        if a.NewSpeciesTracker != nil </span><span class="cov0" title="0">{
                // Use atomic check-and-update to prevent duplicate "new species" notifications
                // when multiple detections of the same species arrive concurrently
                isNewSpecies, daysSinceFirstSeen = a.NewSpeciesTracker.CheckAndUpdateSpecies(a.Note.ScientificName, time.Now())
        }</span>

        // Save note to database
        <span class="cov0" title="0">if err := a.Ds.Save(&amp;a.Note, a.Results); err != nil </span><span class="cov0" title="0">{
                // Add structured logging
                GetLogger().Error("Failed to save note and results to database",
                        "component", "analysis.processor.actions",
                        "error", err,
                        "species", a.Note.CommonName,
                        "scientific_name", a.Note.ScientificName,
                        "confidence", a.Note.Confidence,
                        "clip_name", a.Note.ClipName,
                        "operation", "database_save")
                log.Printf("❌ Failed to save note and results to database")
                return err
        }</span>

        // After successful save, publish detection event for new species
        <span class="cov0" title="0">a.publishNewSpeciesDetectionEvent(isNewSpecies, daysSinceFirstSeen)

        // Save audio clip to file if enabled
        if a.Settings.Realtime.Audio.Export.Enabled </span><span class="cov0" title="0">{
                // export audio clip from capture buffer
                pcmData, err := myaudio.ReadSegmentFromCaptureBuffer(a.Note.Source.ID, a.Note.BeginTime, int(AudioSegmentDuration.Seconds()))
                if err != nil </span><span class="cov0" title="0">{
                        // Add structured logging
                        GetLogger().Error("Failed to read audio segment from buffer",
                                "component", "analysis.processor.actions",
                                "error", err,
                                "species", a.Note.CommonName,
                                "source", a.Note.Source.SafeString,
                                "begin_time", a.Note.BeginTime,
                                "duration_seconds", 15,
                                "operation", "read_audio_segment")
                        log.Printf("❌ Failed to read audio segment from buffer")
                        return err
                }</span>

                // Create a SaveAudioAction and execute it
                <span class="cov0" title="0">saveAudioAction := &amp;SaveAudioAction{
                        Settings: a.Settings,
                        ClipName: a.Note.ClipName,
                        pcmData:  pcmData,
                }

                if err := saveAudioAction.Execute(nil); err != nil </span><span class="cov0" title="0">{
                        // Add structured logging
                        GetLogger().Error("Failed to save audio clip",
                                "component", "analysis.processor.actions",
                                "error", err,
                                "species", a.Note.CommonName,
                                "clip_name", a.Note.ClipName,
                                "operation", "save_audio_clip")
                        log.Printf("❌ Failed to save audio clip")
                        return err
                }</span>

                <span class="cov0" title="0">if a.Settings.Debug </span><span class="cov0" title="0">{
                        // Add structured logging
                        GetLogger().Debug("Saved audio clip successfully",
                                "component", "analysis.processor.actions",
                                "species", a.Note.CommonName,
                                "clip_name", a.Note.ClipName,
                                "detection_time", a.Note.Time,
                                "begin_time", a.Note.BeginTime,
                                "end_time", time.Now(),
                                "operation", "save_audio_clip_debug")
                        log.Printf("✅ Saved audio clip to %s\n", a.Note.ClipName)
                        log.Printf("detection time %v, begin time %v, end time %v\n", a.Note.Time, a.Note.BeginTime, time.Now())
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// publishNewSpeciesDetectionEvent publishes a detection event for new species
// This helper method handles event bus retrieval, event creation, publishing, and debug logging
func (a *DatabaseAction) publishNewSpeciesDetectionEvent(isNewSpecies bool, daysSinceFirstSeen int) <span class="cov0" title="0">{
        if !isNewSpecies || !events.IsInitialized() </span><span class="cov0" title="0">{
                return
        }</span>

        // Store current time for consistent use throughout
        <span class="cov0" title="0">var notificationTime time.Time
        
        // Check notification suppression if tracker is available
        if a.NewSpeciesTracker != nil </span><span class="cov0" title="0">{
                notificationTime = time.Now()
                
                // Check if notification should be suppressed for this species
                if a.NewSpeciesTracker.ShouldSuppressNotification(a.Note.ScientificName, notificationTime) </span><span class="cov0" title="0">{
                        if a.Settings.Debug </span><span class="cov0" title="0">{
                                GetLogger().Debug("Suppressing duplicate new species notification",
                                        "component", "analysis.processor.actions",
                                        "species", a.Note.CommonName,
                                        "scientific_name", a.Note.ScientificName,
                                        "operation", "suppress_notification")
                        }</span>
                        <span class="cov0" title="0">return</span>
                }
        }

        <span class="cov0" title="0">eventBus := events.GetEventBus()
        if eventBus == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Use display name directly from the AudioSource struct for user-facing notifications
        <span class="cov0" title="0">displayLocation := a.Note.Source.DisplayName

        detectionEvent, err := events.NewDetectionEvent(
                a.Note.CommonName,
                a.Note.ScientificName,
                float64(a.Note.Confidence),
                displayLocation,
                isNewSpecies,
                daysSinceFirstSeen,
        )
        if err != nil </span><span class="cov0" title="0">{
                if a.Settings.Debug </span><span class="cov0" title="0">{
                        // Add structured logging
                        GetLogger().Debug("Failed to create detection event",
                                "component", "analysis.processor.actions",
                                "error", err,
                                "species", a.Note.CommonName,
                                "scientific_name", a.Note.ScientificName,
                                "is_new_species", isNewSpecies,
                                "days_since_first_seen", daysSinceFirstSeen,
                                "operation", "create_detection_event")
                        log.Printf("❌ Failed to create detection event: %v", err)
                }</span>
                <span class="cov0" title="0">return</span>
        }

        // Publish the detection event
        <span class="cov0" title="0">if published := eventBus.TryPublishDetection(detectionEvent); published </span><span class="cov0" title="0">{
                // Only record notification as sent if publishing succeeded
                if a.NewSpeciesTracker != nil &amp;&amp; !notificationTime.IsZero() </span><span class="cov0" title="0">{
                        a.NewSpeciesTracker.RecordNotificationSent(a.Note.ScientificName, notificationTime)
                }</span>
                
                <span class="cov0" title="0">if a.Settings.Debug </span><span class="cov0" title="0">{
                        // Add structured logging
                        GetLogger().Debug("Published new species detection event",
                                "component", "analysis.processor.actions",
                                "species", a.Note.CommonName,
                                "scientific_name", a.Note.ScientificName,
                                "confidence", a.Note.Confidence,
                                "is_new_species", isNewSpecies,
                                "days_since_first_seen", daysSinceFirstSeen,
                                "operation", "publish_detection_event")
                        log.Printf("🌟 Published new species detection event: %s", a.Note.CommonName)
                }</span>
        }
}

// Execute saves the audio clip to a file
func (a *SaveAudioAction) Execute(data interface{}) error <span class="cov0" title="0">{
        a.mu.Lock()
        defer a.mu.Unlock()

        // Get the full path by joining the export path with the relative clip name
        outputPath := filepath.Join(a.Settings.Realtime.Audio.Export.Path, a.ClipName)

        // Ensure the directory exists
        if err := os.MkdirAll(filepath.Dir(outputPath), 0o755); err != nil </span><span class="cov0" title="0">{
                // Add structured logging
                GetLogger().Error("Failed to create directory for audio clip",
                        "component", "analysis.processor.actions",
                        "error", err,
                        "output_path", outputPath,
                        "clip_name", a.ClipName,
                        "operation", "create_directory")
                log.Printf("❌ Error creating directory for audio clip")
                return err
        }</span>

        <span class="cov0" title="0">if a.Settings.Realtime.Audio.Export.Type == "wav" </span><span class="cov0" title="0">{
                if err := myaudio.SavePCMDataToWAV(outputPath, a.pcmData); err != nil </span><span class="cov0" title="0">{
                        // Add structured logging
                        GetLogger().Error("Failed to save audio clip to WAV",
                                "component", "analysis.processor.actions",
                                "error", err,
                                "output_path", outputPath,
                                "clip_name", a.ClipName,
                                "format", "wav",
                                "operation", "save_wav")
                        log.Printf("❌ Error saving audio clip to WAV")
                        return err
                }</span>
        } else<span class="cov0" title="0"> {
                if err := myaudio.ExportAudioWithFFmpeg(a.pcmData, outputPath, &amp;a.Settings.Realtime.Audio); err != nil </span><span class="cov0" title="0">{
                        // Add structured logging
                        GetLogger().Error("Failed to export audio clip with FFmpeg",
                                "component", "analysis.processor.actions",
                                "error", err,
                                "output_path", outputPath,
                                "clip_name", a.ClipName,
                                "format", a.Settings.Realtime.Audio.Export.Type,
                                "operation", "ffmpeg_export")
                        log.Printf("❌ Error exporting audio clip with FFmpeg")
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// Execute sends the note to the BirdWeather API
func (a *BirdWeatherAction) Execute(data interface{}) error <span class="cov0" title="0">{
        a.mu.Lock()
        defer a.mu.Unlock()

        species := strings.ToLower(a.Note.CommonName)

        // Check event frequency
        if !a.EventTracker.TrackEvent(species, BirdWeatherSubmit) </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Early check if BirdWeather is still enabled in settings
        <span class="cov0" title="0">if !a.Settings.Realtime.Birdweather.Enabled </span><span class="cov0" title="0">{
                return nil // Silently exit if BirdWeather was disabled after this action was created
        }</span>

        // Add threshold check here
        <span class="cov0" title="0">if a.Note.Confidence &lt; float64(a.Settings.Realtime.Birdweather.Threshold) </span><span class="cov0" title="0">{
                if a.Settings.Debug </span><span class="cov0" title="0">{
                        // Add structured logging
                        GetLogger().Debug("Skipping BirdWeather upload due to low confidence",
                                "component", "analysis.processor.actions",
                                "species", species,
                                "confidence", a.Note.Confidence,
                                "threshold", a.Settings.Realtime.Birdweather.Threshold,
                                "operation", "birdweather_threshold_check")
                        log.Printf("⛔ Skipping BirdWeather upload for %s: confidence %.2f below threshold %.2f\n",
                                species, a.Note.Confidence, a.Settings.Realtime.Birdweather.Threshold)
                }</span>
                <span class="cov0" title="0">return nil</span>
        }

        // Safe check for nil BwClient
        <span class="cov0" title="0">if a.BwClient == nil </span><span class="cov0" title="0">{
                // Client initialization failures indicate configuration issues that require
                // manual intervention (e.g., missing API keys, disabled service)
                // Retrying won't fix these problems, so mark as non-retryable
                return errors.Newf("BirdWeather client is not initialized").
                        Component("analysis.processor").
                        Category(errors.CategoryIntegration).
                        Context("operation", "birdweather_upload").
                        Context("integration", "birdweather").
                        Context("retryable", false). // Configuration error - not retryable
                        Context("config_section", "realtime.birdweather").
                        Build()
        }</span>

        // Copy data locally to reduce lock duration if needed
        <span class="cov0" title="0">note := a.Note
        pcmData := a.pcmData

        // Try to publish with appropriate error handling
        if err := a.BwClient.Publish(&amp;note, pcmData); err != nil </span><span class="cov0" title="0">{
                // Log the error with retry information if retries are enabled
                // Sanitize error before logging
                sanitizedErr := sanitizeError(err)
                // Add structured logging
                GetLogger().Error("Failed to upload to BirdWeather",
                        "component", "analysis.processor.actions",
                        "error", sanitizedErr,
                        "species", note.CommonName,
                        "scientific_name", note.ScientificName,
                        "confidence", note.Confidence,
                        "clip_name", note.ClipName,
                        "retry_enabled", a.RetryConfig.Enabled,
                        "operation", "birdweather_upload")
                if a.RetryConfig.Enabled </span><span class="cov0" title="0">{
                        log.Printf("❌ Error uploading %s (%s) to BirdWeather (confidence: %.2f, clip: %s) (will retry): %v\n",
                                note.CommonName, note.ScientificName, note.Confidence, note.ClipName, sanitizedErr)
                }</span> else<span class="cov0" title="0"> {
                        log.Printf("❌ Error uploading %s (%s) to BirdWeather (confidence: %.2f, clip: %s): %v\n",
                                note.CommonName, note.ScientificName, note.Confidence, note.ClipName, sanitizedErr)
                        // Send notification for non-retryable failures
                        notification.NotifyIntegrationFailure("BirdWeather", err)
                }</span>
                // Network and API errors are typically transient and may succeed on retry:
                // - Temporary network outages
                // - API rate limiting
                // - Server-side temporary failures
                // The job queue will handle exponential backoff for these retryable errors
                <span class="cov0" title="0">return errors.New(err).
                        Component("analysis.processor").
                        Category(errors.CategoryIntegration).
                        Context("operation", "birdweather_upload").
                        Context("species", note.CommonName).
                        Context("confidence", note.Confidence).
                        Context("clip_name", note.ClipName).
                        Context("integration", "birdweather").
                        Context("retryable", true). // Network/API errors are typically retryable
                        Build()</span>
        }

        <span class="cov0" title="0">if a.Settings.Debug </span><span class="cov0" title="0">{
                // Add structured logging
                GetLogger().Debug("Successfully uploaded to BirdWeather",
                        "component", "analysis.processor.actions",
                        "species", a.Note.CommonName,
                        "scientific_name", a.Note.ScientificName,
                        "confidence", a.Note.Confidence,
                        "clip_name", a.Note.ClipName,
                        "operation", "birdweather_upload_success")
                log.Printf("✅ Successfully uploaded %s to BirdWeather\n", a.Note.ClipName)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type NoteWithBirdImage struct {
        datastore.Note
        BirdImage imageprovider.BirdImage
}

// Execute sends the note to the MQTT broker
func (a *MqttAction) Execute(data interface{}) error <span class="cov0" title="0">{
        a.mu.Lock()
        defer a.mu.Unlock()

        // Rely on background reconnect; fail action if not currently connected.
        if !a.MqttClient.IsConnected() </span><span class="cov0" title="0">{
                // Log slightly differently to indicate it's waiting for background reconnect
                // Add structured logging
                GetLogger().Warn("MQTT client not connected, skipping publish",
                        "component", "analysis.processor.actions",
                        "species", a.Note.CommonName,
                        "scientific_name", a.Note.ScientificName,
                        "confidence", a.Note.Confidence,
                        "operation", "mqtt_connection_check",
                        "status", "waiting_reconnect")
                log.Printf("🟡 MQTT client is not connected, skipping publish for %s (%s). Waiting for automatic reconnect.", a.Note.CommonName, a.Note.ScientificName)
                // MQTT connection failures are retryable because:
                // - The MQTT client has automatic reconnection logic
                // - Connection may be temporarily lost due to network issues
                // - Broker may be temporarily unavailable
                // The job queue retry mechanism complements the client's own reconnection
                return errors.Newf("MQTT client not connected").
                        Component("analysis.processor").
                        Category(errors.CategoryMQTTConnection).
                        Context("operation", "mqtt_publish").
                        Context("integration", "mqtt").
                        Context("retryable", true). // Connection issues are retryable
                        Build()
        }</span>

        <span class="cov0" title="0">species := strings.ToLower(a.Note.CommonName)

        // Check event frequency
        if !a.EventTracker.TrackEvent(species, MQTTPublish) </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Validate MQTT settings
        <span class="cov0" title="0">if a.Settings.Realtime.MQTT.Topic == "" </span><span class="cov0" title="0">{
                return errors.Newf("MQTT topic is not specified").
                        Component("analysis.processor").
                        Category(errors.CategoryConfiguration).
                        Context("operation", "mqtt_publish").
                        Context("integration", "mqtt").
                        Context("retryable", false). // Configuration error - not retryable
                        Context("config_section", "realtime.mqtt.topic").
                        Build()
        }</span>

        // Get bird image of detected bird
        <span class="cov0" title="0">birdImage := imageprovider.BirdImage{} // Default to empty image
        // Add nil check for BirdImageCache before calling Get
        if a.BirdImageCache != nil </span><span class="cov0" title="0">{
                var err error
                birdImage, err = a.BirdImageCache.Get(a.Note.ScientificName)
                if err != nil </span><span class="cov0" title="0">{
                        // Add structured logging
                        GetLogger().Warn("Error getting bird image from cache",
                                "component", "analysis.processor.actions",
                                "error", err,
                                "species", a.Note.CommonName,
                                "scientific_name", a.Note.ScientificName,
                                "operation", "get_bird_image")
                        log.Printf("⚠️ Error getting bird image from cache for %s: %v", a.Note.ScientificName, err)
                        // Continue with the default empty image
                }</span>
        } else<span class="cov0" title="0"> {
                // Log if the cache is nil, maybe helpful for debugging setup issues
                // Add structured logging
                GetLogger().Warn("BirdImageCache is nil, cannot fetch image",
                        "component", "analysis.processor.actions",
                        "species", a.Note.CommonName,
                        "scientific_name", a.Note.ScientificName,
                        "operation", "check_bird_image_cache")
                log.Printf("🟡 BirdImageCache is nil, cannot fetch image for %s", a.Note.ScientificName)
        }</span>

        // Create a copy of the Note (source is already sanitized in SafeString field)
        <span class="cov0" title="0">noteCopy := a.Note

        // Wrap note with bird image (using copy)
        noteWithBirdImage := NoteWithBirdImage{Note: noteCopy, BirdImage: birdImage}

        // Create a JSON representation of the note
        noteJson, err := json.Marshal(noteWithBirdImage)
        if err != nil </span><span class="cov0" title="0">{
                // Add structured logging
                GetLogger().Error("Failed to marshal note to JSON",
                        "component", "analysis.processor.actions",
                        "error", err,
                        "species", a.Note.CommonName,
                        "scientific_name", a.Note.ScientificName,
                        "operation", "json_marshal")
                log.Printf("❌ Error marshalling note to JSON")
                return err
        }</span>

        // Create a context with timeout for publishing
        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(context.Background(), MQTTPublishTimeout)
        defer cancel()

        // Publish the note to the MQTT broker
        err = a.MqttClient.Publish(ctx, a.Settings.Realtime.MQTT.Topic, string(noteJson))
        if err != nil </span><span class="cov0" title="0">{
                // Log the error with retry information if retries are enabled
                // Sanitize error before logging
                sanitizedErr := sanitizeError(err)
                // Add structured logging
                GetLogger().Error("Failed to publish to MQTT",
                        "component", "analysis.processor.actions",
                        "error", sanitizedErr,
                        "species", a.Note.CommonName,
                        "scientific_name", a.Note.ScientificName,
                        "confidence", a.Note.Confidence,
                        "clip_name", a.Note.ClipName,
                        "topic", a.Settings.Realtime.MQTT.Topic,
                        "retry_enabled", a.RetryConfig.Enabled,
                        "operation", "mqtt_publish")
                if a.RetryConfig.Enabled </span><span class="cov0" title="0">{
                        log.Printf("❌ Error publishing %s (%s) to MQTT topic %s (confidence: %.2f, clip: %s) (will retry): %v\n",
                                a.Note.CommonName, a.Note.ScientificName, a.Settings.Realtime.MQTT.Topic, a.Note.Confidence, a.Note.ClipName, sanitizedErr)
                }</span> else<span class="cov0" title="0"> {
                        log.Printf("❌ Error publishing %s (%s) to MQTT topic %s (confidence: %.2f, clip: %s): %v\n",
                                a.Note.CommonName, a.Note.ScientificName, a.Settings.Realtime.MQTT.Topic, a.Note.Confidence, a.Note.ClipName, sanitizedErr)
                        // Send notification for non-retryable failures
                        notification.NotifyIntegrationFailure("MQTT", err)
                }</span>
                <span class="cov0" title="0">return errors.New(err).
                        Component("analysis.processor").
                        Category(errors.CategoryMQTTPublish).
                        Context("operation", "mqtt_publish").
                        Context("species", a.Note.CommonName).
                        Context("confidence", a.Note.Confidence).
                        Context("topic", a.Settings.Realtime.MQTT.Topic).
                        Context("clip_name", a.Note.ClipName).
                        Context("integration", "mqtt").
                        Context("retryable", true). // MQTT publish failures are typically retryable
                        Build()</span>
        }

        <span class="cov0" title="0">if a.Settings.Debug </span><span class="cov0" title="0">{
                // Add structured logging
                GetLogger().Debug("Successfully published to MQTT",
                        "component", "analysis.processor.actions",
                        "species", a.Note.CommonName,
                        "scientific_name", a.Note.ScientificName,
                        "confidence", a.Note.Confidence,
                        "topic", a.Settings.Realtime.MQTT.Topic,
                        "operation", "mqtt_publish_success")
                log.Printf("✅ Successfully published %s to MQTT topic %s\n",
                        a.Note.CommonName, a.Settings.Realtime.MQTT.Topic)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Execute updates the range filter species list, this is run every day
func (a *UpdateRangeFilterAction) Execute(data interface{}) error <span class="cov0" title="0">{
        a.mu.Lock()
        defer a.mu.Unlock()

        today := time.Now().Truncate(24 * time.Hour)
        if today.After(a.Settings.BirdNET.RangeFilter.LastUpdated) </span><span class="cov0" title="0">{
                // Update location based species list
                speciesScores, err := a.Bn.GetProbableSpecies(today, 0.0)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Convert the speciesScores slice to a slice of species labels
                <span class="cov0" title="0">var includedSpecies []string
                for _, speciesScore := range speciesScores </span><span class="cov0" title="0">{
                        includedSpecies = append(includedSpecies, speciesScore.Label)
                }</span>

                <span class="cov0" title="0">a.Settings.UpdateIncludedSpecies(includedSpecies)</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// Execute broadcasts the detection via Server-Sent Events
func (a *SSEAction) Execute(data interface{}) error <span class="cov0" title="0">{
        a.mu.Lock()
        defer a.mu.Unlock()

        // Check if SSE broadcaster is available
        if a.SSEBroadcaster == nil </span><span class="cov0" title="0">{
                return nil // Silently skip if no broadcaster is configured
        }</span>

        <span class="cov0" title="0">species := strings.ToLower(a.Note.CommonName)

        // Check event frequency
        if !a.EventTracker.TrackEvent(species, SSEBroadcast) </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Wait for audio file to be available if this detection has an audio clip assigned
        // This properly handles per-species audio settings and avoids false positives
        <span class="cov0" title="0">if a.Note.ClipName != "" </span><span class="cov0" title="0">{
                if err := a.waitForAudioFile(); err != nil </span><span class="cov0" title="0">{
                        // Log warning but don't fail the SSE broadcast
                        // Add structured logging
                        GetLogger().Warn("Audio file not ready for SSE broadcast",
                                "component", "analysis.processor.actions",
                                "error", err,
                                "species", a.Note.CommonName,
                                "clip_name", a.Note.ClipName,
                                "operation", "sse_wait_audio_file")
                        log.Printf("⚠️ Audio file not ready for %s, broadcasting without waiting: %v", a.Note.CommonName, err)
                }</span>
        }

        // Wait for database ID to be assigned if Note.ID is 0 (new detection)
        // This ensures the frontend can properly load audio/spectrogram via API endpoints
        <span class="cov0" title="0">if a.Note.ID == 0 </span><span class="cov0" title="0">{
                if err := a.waitForDatabaseID(); err != nil </span><span class="cov0" title="0">{
                        // Log warning but don't fail the SSE broadcast
                        // Add structured logging
                        GetLogger().Warn("Database ID not ready for SSE broadcast",
                                "component", "analysis.processor.actions",
                                "error", err,
                                "species", a.Note.CommonName,
                                "note_id", a.Note.ID,
                                "operation", "sse_wait_database_id")
                        log.Printf("⚠️ Database ID not ready for %s, broadcasting with ID=0: %v", a.Note.CommonName, err)
                }</span>
        }

        // Get bird image of detected bird
        <span class="cov0" title="0">birdImage := imageprovider.BirdImage{} // Default to empty image
        // Add nil check for BirdImageCache before calling Get
        if a.BirdImageCache != nil </span><span class="cov0" title="0">{
                var err error
                birdImage, err = a.BirdImageCache.Get(a.Note.ScientificName)
                if err != nil </span><span class="cov0" title="0">{
                        // Add structured logging
                        GetLogger().Warn("Error getting bird image from cache",
                                "component", "analysis.processor.actions",
                                "error", err,
                                "species", a.Note.CommonName,
                                "scientific_name", a.Note.ScientificName,
                                "operation", "get_bird_image")
                        log.Printf("⚠️ Error getting bird image from cache for %s: %v", a.Note.ScientificName, err)
                        // Continue with the default empty image
                }</span>
        } else<span class="cov0" title="0"> {
                // Log if the cache is nil, maybe helpful for debugging setup issues
                // Add structured logging
                GetLogger().Warn("BirdImageCache is nil, cannot fetch image",
                        "component", "analysis.processor.actions",
                        "species", a.Note.CommonName,
                        "scientific_name", a.Note.ScientificName,
                        "operation", "check_bird_image_cache")
                log.Printf("🟡 BirdImageCache is nil, cannot fetch image for %s", a.Note.ScientificName)
        }</span>

        // Create a copy of the Note (source is already sanitized in SafeString field)
        <span class="cov0" title="0">noteCopy := a.Note

        // Broadcast the detection with error handling
        if err := a.SSEBroadcaster(&amp;noteCopy, &amp;birdImage); err != nil </span><span class="cov0" title="0">{
                // Log the error with retry information if retries are enabled
                // Sanitize error before logging
                sanitizedErr := sanitizeError(err)
                // Add structured logging
                GetLogger().Error("Failed to broadcast via SSE",
                        "component", "analysis.processor.actions",
                        "error", sanitizedErr,
                        "species", a.Note.CommonName,
                        "scientific_name", a.Note.ScientificName,
                        "confidence", a.Note.Confidence,
                        "clip_name", a.Note.ClipName,
                        "retry_enabled", a.RetryConfig.Enabled,
                        "operation", "sse_broadcast")
                if a.RetryConfig.Enabled </span><span class="cov0" title="0">{
                        log.Printf("❌ Error broadcasting %s (%s) via SSE (confidence: %.2f, clip: %s) (will retry): %v\n",
                                a.Note.CommonName, a.Note.ScientificName, a.Note.Confidence, a.Note.ClipName, sanitizedErr)
                }</span> else<span class="cov0" title="0"> {
                        log.Printf("❌ Error broadcasting %s (%s) via SSE (confidence: %.2f, clip: %s): %v\n",
                                a.Note.CommonName, a.Note.ScientificName, a.Note.Confidence, a.Note.ClipName, sanitizedErr)
                }</span>
                <span class="cov0" title="0">return errors.New(err).
                        Component("analysis.processor").
                        Category(errors.CategoryBroadcast).
                        Context("operation", "sse_broadcast").
                        Context("species", a.Note.CommonName).
                        Context("confidence", a.Note.Confidence).
                        Context("clip_name", a.Note.ClipName).
                        Context("retryable", true). // SSE broadcast failures are typically retryable
                        Build()</span>
        }

        <span class="cov0" title="0">if a.Settings.Debug </span><span class="cov0" title="0">{
                // Add structured logging
                GetLogger().Debug("Successfully broadcasted via SSE",
                        "component", "analysis.processor.actions",
                        "species", a.Note.CommonName,
                        "scientific_name", a.Note.ScientificName,
                        "confidence", a.Note.Confidence,
                        "clip_name", a.Note.ClipName,
                        "operation", "sse_broadcast_success")
                log.Printf("✅ Successfully broadcasted %s via SSE\n", a.Note.CommonName)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// waitForAudioFile waits for the audio file to be written to disk with a timeout
func (a *SSEAction) waitForAudioFile() error <span class="cov0" title="0">{
        if a.Note.ClipName == "" </span><span class="cov0" title="0">{
                return nil // No audio file expected
        }</span>

        // Build the full path to the audio file using the configured export path
        <span class="cov0" title="0">audioPath := filepath.Join(a.Settings.Realtime.Audio.Export.Path, a.Note.ClipName)

        // Wait for file to be written
        deadline := time.Now().Add(SSEAudioFileTimeout)

        for time.Now().Before(deadline) </span><span class="cov0" title="0">{
                // Check if file exists and has content
                if info, err := os.Stat(audioPath); err == nil </span><span class="cov0" title="0">{
                        // File exists, check if it has reasonable size
                        if info.Size() &gt; MinAudioFileSize </span><span class="cov0" title="0">{
                                if a.Settings.Debug </span><span class="cov0" title="0">{
                                        // Add structured logging
                                        GetLogger().Debug("Audio file ready for SSE broadcast",
                                                "component", "analysis.processor.actions",
                                                "clip_name", a.Note.ClipName,
                                                "file_size_bytes", info.Size(),
                                                "species", a.Note.CommonName,
                                                "operation", "wait_audio_file_success")
                                        log.Printf("🎵 Audio file ready for SSE broadcast: %s (size: %d bytes)", a.Note.ClipName, info.Size())
                                }</span>
                                <span class="cov0" title="0">return nil</span>
                        }
                        // File exists but might still be writing, wait a bit more
                }

                <span class="cov0" title="0">time.Sleep(SSEAudioCheckInterval)</span>
        }

        // Timeout reached
        <span class="cov0" title="0">return errors.Newf("audio file %s not ready after %v timeout", a.Note.ClipName, SSEAudioFileTimeout).
                Component("analysis.processor").
                Category(errors.CategoryTimeout).
                Context("operation", "wait_for_audio_file").
                Context("clip_name", a.Note.ClipName).
                Context("timeout_seconds", SSEAudioFileTimeout.Seconds()).
                Build()</span>
}

// waitForDatabaseID waits for the Note to be saved to database and ID assigned
func (a *SSEAction) waitForDatabaseID() error <span class="cov0" title="0">{
        // We need to query the database to find this note by unique characteristics
        // Since we don't have the ID yet, we'll search by time, species, and confidence
        deadline := time.Now().Add(SSEDatabaseIDTimeout)

        for time.Now().Before(deadline) </span><span class="cov0" title="0">{
                // Query database for a note matching our characteristics
                // Use a small time window around the detection time to find the record
                if updatedNote, err := a.findNoteInDatabase(); err == nil &amp;&amp; updatedNote.ID &gt; 0 </span><span class="cov0" title="0">{
                        // Found the note with an ID, update our copy
                        a.Note.ID = updatedNote.ID
                        if a.Settings.Debug </span><span class="cov0" title="0">{
                                // Add structured logging
                                GetLogger().Debug("Found database ID for SSE broadcast",
                                        "component", "analysis.processor.actions",
                                        "database_id", updatedNote.ID,
                                        "species", a.Note.CommonName,
                                        "scientific_name", a.Note.ScientificName,
                                        "operation", "wait_database_id_success")
                                log.Printf("🔍 Found database ID %d for SSE broadcast: %s", updatedNote.ID, a.Note.CommonName)
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                }

                <span class="cov0" title="0">time.Sleep(SSEDatabaseCheckInterval)</span>
        }

        // Timeout reached
        <span class="cov0" title="0">return errors.Newf("database ID not assigned for %s after %v timeout", a.Note.CommonName, SSEDatabaseIDTimeout).
                Component("analysis.processor").
                Category(errors.CategoryTimeout).
                Context("operation", "wait_for_database_id").
                Context("species", a.Note.CommonName).
                Context("timeout_seconds", SSEDatabaseIDTimeout.Seconds()).
                Build()</span>
}

// findNoteInDatabase searches for the note in database by unique characteristics
func (a *SSEAction) findNoteInDatabase() (*datastore.Note, error) <span class="cov0" title="0">{
        if a.Ds == nil </span><span class="cov0" title="0">{
                return nil, errors.Newf("datastore not available").
                        Component("analysis.processor").
                        Category(errors.CategoryDatabase).
                        Context("operation", "find_note_in_database").
                        Context("retryable", false). // System configuration issue - not retryable
                        Build()
        }</span>

        // Search for notes with matching characteristics
        // The SearchNotes method expects a search query string that will match against
        // common_name or scientific_name fields
        <span class="cov0" title="0">query := a.Note.ScientificName

        // Search for notes, sorted by ID descending to get the most recent
        notes, err := a.Ds.SearchNotes(query, false, DatabaseSearchLimit, 0) // false = sort descending, offset 0
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New(err).
                        Component("analysis.processor").
                        Category(errors.CategoryDatabase).
                        Context("operation", "search_notes").
                        Context("query", query).
                        Build()
        }</span>

        // Filter results to find the exact match based on date and time
        <span class="cov0" title="0">for i := range notes </span><span class="cov0" title="0">{
                note := &amp;notes[i]
                // Check if this note matches our expected characteristics
                if note.Date == a.Note.Date &amp;&amp;
                        note.ScientificName == a.Note.ScientificName &amp;&amp;
                        note.Time == a.Note.Time </span><span class="cov0" title="0">{ // Exact time match
                        return note, nil
                }</span>
        }

        <span class="cov0" title="0">return nil, errors.Newf("note not found in database").
                Component("analysis.processor").
                Category(errors.CategoryNotFound).
                Context("operation", "find_note_in_database").
                Context("species", a.Note.ScientificName).
                Context("date", a.Note.Date).
                Context("time", a.Note.Time).
                Build()</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// dogbarkfilter.go
package processor

import (
        "strings"
        "time"

        "github.com/tphakala/birdnet-go/internal/conf"
)

// Assuming a predefined time limit for filtering detections after a dog bark.
var DogBarkFilterTimeLimit = time.Duration(conf.Setting().Realtime.DogBarkFilter.Remember) * time.Minute

// Check if the species should be filtered based on the last dog bark timestamp.
func (p *Processor) CheckDogBarkFilter(species string, lastDogBark time.Time) bool <span class="cov0" title="0">{
        species = strings.ToLower(species)
        for _, s := range p.Settings.Realtime.DogBarkFilter.Species </span><span class="cov0" title="0">{
                if s == species </span><span class="cov0" title="0">{
                        return time.Since(lastDogBark) &lt;= DogBarkFilterTimeLimit
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package processor

import (
        "time"

        "github.com/tphakala/birdnet-go/internal/datastore"
)

// addSpeciesToDynamicThresholds adds a species to the dynamic thresholds map if it doesn't already exist.
func (p *Processor) addSpeciesToDynamicThresholds(speciesLowercase string, baseThreshold float32) <span class="cov0" title="0">{
        // Lock the mutex to ensure thread-safe access to the DynamicThresholds map
        p.thresholdsMutex.Lock()
        defer p.thresholdsMutex.Unlock()

        // Check if the species already has a dynamic threshold
        _, exists := p.DynamicThresholds[speciesLowercase]

        // If it doesn't exist, initialize it
        if !exists </span><span class="cov0" title="0">{
                if p.Settings.Realtime.DynamicThreshold.Debug </span><span class="cov0" title="0">{
                        logger := GetLogger()
                        logger.Debug("Initializing dynamic threshold", "species", speciesLowercase)
                }</span>
                <span class="cov0" title="0">p.DynamicThresholds[speciesLowercase] = &amp;DynamicThreshold{
                        Level:         0,
                        CurrentValue:  float64(baseThreshold),
                        Timer:         time.Now(),
                        HighConfCount: 0,
                        ValidHours:    p.Settings.Realtime.DynamicThreshold.ValidHours,
                }</span>
        }
}

// getAdjustedConfidenceThreshold applies dynamic threshold logic to adjust the confidence threshold based on recent detections.
func (p *Processor) getAdjustedConfidenceThreshold(speciesLowercase string, result datastore.Results, baseThreshold float32) float32 <span class="cov0" title="0">{
        // Lock the mutex to ensure thread-safe access to the DynamicThresholds map
        p.thresholdsMutex.Lock()
        defer p.thresholdsMutex.Unlock()

        // Get the dynamic threshold for the species
        dt, exists := p.DynamicThresholds[speciesLowercase]

        // If it doesn't exist, return the base threshold
        if !exists </span><span class="cov0" title="0">{
                return baseThreshold
        }</span>

        // If the detection confidence exceeds the trigger threshold
        <span class="cov0" title="0">if result.Confidence &gt; float32(p.Settings.Realtime.DynamicThreshold.Trigger) </span><span class="cov0" title="0">{
                dt.HighConfCount++
                dt.Timer = time.Now().Add(time.Duration(dt.ValidHours) * time.Hour)

                // Adjust the dynamic threshold based on the number of high-confidence detections
                switch dt.HighConfCount </span>{
                case 1:<span class="cov0" title="0">
                        dt.Level = 1
                        dt.CurrentValue = float64(baseThreshold * 0.75)</span>
                case 2:<span class="cov0" title="0">
                        dt.Level = 2
                        dt.CurrentValue = float64(baseThreshold * 0.5)</span>
                case 3:<span class="cov0" title="0">
                        dt.Level = 3
                        dt.CurrentValue = float64(baseThreshold * 0.25)</span>
                }
        } else<span class="cov0" title="0"> if time.Now().After(dt.Timer) </span><span class="cov0" title="0">{
                // Reset the dynamic threshold if the timer has expired
                dt.Level = 0
                dt.CurrentValue = float64(baseThreshold)
                dt.HighConfCount = 0
        }</span>

        // Ensure the dynamic threshold doesn't fall below the minimum threshold
        <span class="cov0" title="0">if dt.CurrentValue &lt; p.Settings.Realtime.DynamicThreshold.Min </span><span class="cov0" title="0">{
                dt.CurrentValue = p.Settings.Realtime.DynamicThreshold.Min
        }</span>

        <span class="cov0" title="0">return float32(dt.CurrentValue)</span>
}

// updateDynamicThreshold updates the dynamic threshold for a given species if enabled.
func (p *Processor) updateDynamicThreshold(commonName string, confidence float64) <span class="cov0" title="0">{
        if p.Settings.Realtime.DynamicThreshold.Enabled </span><span class="cov0" title="0">{
                // Lock the mutex to ensure thread-safe access to the DynamicThresholds map
                p.thresholdsMutex.Lock()
                defer p.thresholdsMutex.Unlock()

                // Check if the species already has a dynamic threshold
                if dt, exists := p.DynamicThresholds[commonName]; exists &amp;&amp; confidence &gt; float64(p.getBaseConfidenceThreshold(commonName)) </span><span class="cov0" title="0">{
                        // Update the timer to extend the threshold's validity
                        dt.Timer = time.Now().Add(time.Duration(dt.ValidHours) * time.Hour)
                        // Since we're modifying a struct in the map, we need to reassign it
                        p.DynamicThresholds[commonName] = dt
                }</span>
        }
}

// cleanUpDynamicThresholds removes stale dynamic thresholds for species that haven't been detected for a long time.
func (p *Processor) cleanUpDynamicThresholds() <span class="cov0" title="0">{
        // Calculate the duration after which a dynamic threshold is considered stale
        staleDuration := time.Duration(p.Settings.Realtime.DynamicThreshold.ValidHours) * time.Hour

        // Get the current time
        now := time.Now()

        // Lock the mutex to ensure thread-safe access to the DynamicThresholds map
        p.thresholdsMutex.Lock()
        defer p.thresholdsMutex.Unlock()

        // Iterate through all species in the DynamicThresholds map
        for species, dt := range p.DynamicThresholds </span><span class="cov0" title="0">{
                // Check if the threshold for this species is stale
                if now.Sub(dt.Timer) &gt; staleDuration </span><span class="cov0" title="0">{
                        // If debug mode is enabled, log the removal of the stale threshold
                        if p.Settings.Realtime.DynamicThreshold.Debug </span><span class="cov0" title="0">{
                                logger := GetLogger()
                                logger.Debug("Removing stale dynamic threshold", "species", species)
                        }</span>
                        // Remove the stale threshold from the map
                        <span class="cov0" title="0">delete(p.DynamicThresholds, species)</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file3" style="display: none">// eventtracker.go
package processor

import (
        "strings"
        "sync"
        "time"

        "github.com/tphakala/birdnet-go/internal/conf"
)

// EventType represents the types of events to be tracked.
type EventType int

const (
        DatabaseSave      EventType = iota // Represents a database save event
        LogToFile                          // Represents a log to file event
        SendNotification                   // Represents a send notification event
        BirdWeatherSubmit                  // Represents a bird weather submit event
        MQTTPublish                        // Represents an MQTT publish event
        SSEBroadcast                       // Represents a Server-Sent Events broadcast
)

// EventBehaviorFunc defines the signature for functions that determine the behavior of an event.
// It returns true if the event is allowed to be processed based on the given last event time and timeout.
type EventBehaviorFunc func(lastEventTime time.Time, timeout time.Duration) bool

// EventHandler holds the state and behavior for a specific event type.
type EventHandler struct {
        LastEventTime map[string]time.Time // Tracks the last event time for each species
        BehaviorFunc  EventBehaviorFunc    // Function that defines the event handling behavior
        Mutex         sync.Mutex           // Mutex to ensure thread-safe access
}

// NewEventHandler creates a new EventHandler with the specified timeout and behavior function.
func NewEventHandler(timeout time.Duration, behaviorFunc EventBehaviorFunc) *EventHandler <span class="cov0" title="0">{
        return &amp;EventHandler{
                LastEventTime: make(map[string]time.Time),
                BehaviorFunc:  behaviorFunc,
        }
}</span>

// shouldHandleEventLocked is a helper method that performs the event handling logic
// without locking. It assumes the caller already holds the Mutex lock.
// This eliminates duplication between ShouldHandleEvent and TrackEvent.
func (h *EventHandler) shouldHandleEventLocked(species string, timeout time.Duration) bool <span class="cov0" title="0">{
        // Normalize species name to lowercase for consistent key usage
        normalizedSpecies := strings.ToLower(species)

        lastTime, exists := h.LastEventTime[normalizedSpecies]
        if !exists || h.BehaviorFunc(lastTime, timeout) </span><span class="cov0" title="0">{
                h.LastEventTime[normalizedSpecies] = time.Now()
                return true
        }</span>
        <span class="cov0" title="0">return false</span>
}

// ShouldHandleEvent determines whether an event for a given species should be handled,
// based on the last event time and the specified timeout.
func (h *EventHandler) ShouldHandleEvent(species string, timeout time.Duration) bool <span class="cov0" title="0">{
        h.Mutex.Lock()
        defer h.Mutex.Unlock()

        return h.shouldHandleEventLocked(species, timeout)
}</span>

// ResetEvent clears the last event time for a given species, effectively resetting its state.
func (h *EventHandler) ResetEvent(species string) <span class="cov0" title="0">{
        h.Mutex.Lock()
        defer h.Mutex.Unlock()
        delete(h.LastEventTime, strings.ToLower(species))
}</span>

// StandardEventBehavior is a default behavior function that allows an event to be handled
// if the current time is greater than the last event time plus the timeout.
func StandardEventBehavior(lastEventTime time.Time, timeout time.Duration) bool <span class="cov0" title="0">{
        return time.Since(lastEventTime) &gt;= timeout
}</span>

// EventTracker manages event handling for different species across multiple event types.
type EventTracker struct {
        Handlers        map[EventType]*EventHandler
        SpeciesConfigs  map[string]conf.SpeciesConfig // Add this: Store species-specific configurations
        DefaultInterval time.Duration                 // Add this: Store the global default interval
        Mutex           sync.RWMutex                  // Mutex to ensure thread-safe access
}

// Add this new struct to hold configuration
type EventTrackerConfig struct {
        DatabaseSaveInterval      time.Duration
        LogToFileInterval         time.Duration
        NotificationInterval      time.Duration
        BirdWeatherSubmitInterval time.Duration
        MQTTPublishInterval       time.Duration
        SSEBroadcastInterval      time.Duration
}

// initEventTracker is a helper function that initializes an EventTracker with common setup
func initEventTracker(interval time.Duration, speciesConfigs map[string]conf.SpeciesConfig) *EventTracker <span class="cov0" title="0">{
        // Create normalized species configs map
        normalizedSpeciesConfigs := make(map[string]conf.SpeciesConfig)
        // Range is safe on nil maps, will iterate 0 times
        for species, config := range speciesConfigs </span><span class="cov0" title="0">{
                normalizedSpeciesConfigs[strings.ToLower(species)] = config
        }</span>

        <span class="cov0" title="0">return &amp;EventTracker{
                DefaultInterval: interval,
                Handlers: map[EventType]*EventHandler{
                        DatabaseSave:      NewEventHandler(interval, StandardEventBehavior),
                        LogToFile:         NewEventHandler(interval, StandardEventBehavior),
                        SendNotification:  NewEventHandler(interval, StandardEventBehavior),
                        BirdWeatherSubmit: NewEventHandler(interval, StandardEventBehavior),
                        MQTTPublish:       NewEventHandler(interval, StandardEventBehavior),
                        SSEBroadcast:      NewEventHandler(interval, StandardEventBehavior),
                },
                SpeciesConfigs: normalizedSpeciesConfigs, // Always initialized, even if empty
        }</span>
}

// NewEventTracker creates a new EventTracker with the default interval
func NewEventTracker(interval time.Duration) *EventTracker <span class="cov0" title="0">{
        return initEventTracker(interval, nil)
}</span>

// NewEventTrackerWithConfig creates a new EventTracker with a default interval and species-specific configurations.
func NewEventTrackerWithConfig(defaultInterval time.Duration, speciesConfigs map[string]conf.SpeciesConfig) *EventTracker <span class="cov0" title="0">{
        return initEventTracker(defaultInterval, speciesConfigs)
}</span>

// TrackEvent checks if an event for a given species and event type should be processed.
// It utilizes the respective event handler to make this determination, considering species-specific intervals.
func (et *EventTracker) TrackEvent(species string, eventType EventType) bool <span class="cov0" title="0">{
        // Normalize species key consistently for all map lookups
        normalizedSpecies := strings.ToLower(species)

        // LOCKING STRATEGY:
        // 1. First, we acquire a read lock on the EventTracker mutex to safely access shared maps (Handlers and SpeciesConfigs)
        //    This protects against concurrent access to these maps by multiple goroutines
        et.Mutex.RLock()

        handler, exists := et.Handlers[eventType]
        if !exists </span><span class="cov0" title="0">{
                et.Mutex.RUnlock()
                return false // Should not happen if EventTracker is initialized correctly
        }</span>

        // Determine the effective timeout for this species and event type
        <span class="cov0" title="0">effectiveTimeout := et.DefaultInterval // Start with the global default

        if speciesConfig, ok := et.SpeciesConfigs[normalizedSpecies]; ok </span><span class="cov0" title="0">{
                if speciesConfig.Interval &gt; 0 </span><span class="cov0" title="0">{
                        // Custom interval is set and valid (positive value)
                        effectiveTimeout = time.Duration(speciesConfig.Interval) * time.Second
                }</span> else<span class="cov0" title="0"> if speciesConfig.Interval &lt; 0 </span><span class="cov0" title="0">{
                        // Log a warning for negative interval values
                        logger := GetLogger()
                        logger.Warn("Negative interval configured for species, using default interval instead",
                                "interval", speciesConfig.Interval,
                                "species", species)
                        // Continue using the default interval
                }</span>
                // For zero interval, silently use the default interval (existing behavior)
        }

        // 2. We unlock the EventTracker mutex BEFORE acquiring the handler's mutex
        //    This is critical to prevent deadlocks that could occur if:
        //    - Thread A: Holds EventTracker lock, waiting for Handler lock
        //    - Thread B: Holds Handler lock, waiting for EventTracker lock
        //    By releasing the outer lock first, we establish a consistent lock ordering
        <span class="cov0" title="0">et.Mutex.RUnlock()

        // 3. Now we lock the handler's mutex to safely access and update its LastEventTime map
        //    This ensures thread-safety for the specific handler while allowing other event types
        //    to be processed concurrently
        handler.Mutex.Lock()
        // Use the shared helper method to evaluate whether the event should be handled
        // Pass the effective timeout as a parameter rather than modifying handler.Timeout
        allowEvent := handler.shouldHandleEventLocked(normalizedSpecies, effectiveTimeout)
        handler.Mutex.Unlock()

        return allowEvent</span>
}

// ResetEvent resets the state for a specific species and event type, clearing any tracked event timing.
func (et *EventTracker) ResetEvent(species string, eventType EventType) <span class="cov0" title="0">{
        // Normalize species key consistently
        normalizedSpecies := strings.ToLower(species)

        // First lock EventTracker mutex to safely access handler map
        et.Mutex.RLock()
        handler, exists := et.Handlers[eventType]
        // Release EventTracker mutex before acquiring handler mutex to match lock ordering in TrackEvent
        et.Mutex.RUnlock()

        if exists </span><span class="cov0" title="0">{
                // Now lock handler mutex to update its state
                handler.ResetEvent(normalizedSpecies)
        }</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">// execute.go
package processor

import (
        "context"
        "fmt"
        "os"
        "os/exec"
        "path/filepath"
        "reflect"
        "runtime"
        "slices"
        "strings"
        "time"

        "github.com/tphakala/birdnet-go/internal/datastore"
        "github.com/tphakala/birdnet-go/internal/errors"
)

type ExecuteCommandAction struct {
        Command string
        Params  map[string]any
}

// GetDescription returns a description of the action
func (a ExecuteCommandAction) GetDescription() string <span class="cov0" title="0">{
        return fmt.Sprintf("Execute command: %s", a.Command)
}</span>

// Execute implements the Action interface for backward compatibility
func (a ExecuteCommandAction) Execute(data any) error <span class="cov0" title="0">{
        // Use a default context with timeout
        ctx, cancel := context.WithTimeout(context.Background(), ExecuteCommandTimeout)
        defer cancel()
        return a.ExecuteContext(ctx, data)
}</span>

// ExecuteContext implements the ContextAction interface for proper context propagation
func (a ExecuteCommandAction) ExecuteContext(ctx context.Context, data any) error <span class="cov0" title="0">{
        logger := GetLogger()
        logger.Info("Executing command", "command", a.Command, "params", a.Params)

        // Type assertion to check if data is of type Detections
        detection, ok := data.(Detections)
        if !ok </span><span class="cov0" title="0">{
                return errors.Newf("ExecuteCommandAction requires Detections type, got %T", data).
                        Component("analysis.processor").
                        Category(errors.CategoryValidation).
                        Context("operation", "execute_command").
                        Context("expected_type", "Detections").
                        Build()
        }</span>

        // Validate and resolve the command path
        <span class="cov0" title="0">cmdPath, err := validateCommandPath(a.Command)
        if err != nil </span><span class="cov0" title="0">{
                return errors.New(err).
                        Component("analysis.processor").
                        Category(errors.CategoryValidation).
                        Context("operation", "validate_command_path").
                        Context("command_type", "external_script").
                        Build()
        }</span>

        // Building the command line arguments with validation
        <span class="cov0" title="0">args, err := buildSafeArguments(a.Params, &amp;detection.Note)
        if err != nil </span><span class="cov0" title="0">{
                // Extract parameter keys for better error context
                var paramKeys []string
                for key := range a.Params </span><span class="cov0" title="0">{
                        paramKeys = append(paramKeys, key)
                }</span>
                <span class="cov0" title="0">return errors.New(err).
                        Component("analysis.processor").
                        Category(errors.CategoryValidation).
                        Context("operation", "build_command_arguments").
                        Context("param_count", len(a.Params)).
                        Context("param_keys", strings.Join(paramKeys, ", ")).
                        Build()</span>
        }

        <span class="cov0" title="0">logger.Debug("Executing command with arguments", "command_path", cmdPath, "args", args)

        // Create command with timeout, inheriting from parent context
        // This ensures cancellation propagates from CompositeAction
        cmdCtx, cancel := context.WithTimeout(ctx, ExecuteCommandTimeout)
        defer cancel()
        
        cmd := exec.CommandContext(cmdCtx, cmdPath, args...)

        // Set a clean environment
        cmd.Env = getCleanEnvironment()

        // Execute the command with timing
        // Timing information helps identify performance issues and hanging scripts
        startTime := time.Now()
        output, err := cmd.CombinedOutput()
        executionDuration := time.Since(startTime)
        
        if err != nil </span><span class="cov0" title="0">{
                // Get exit code if available
                exitCode := -1
                if cmd.ProcessState != nil </span><span class="cov0" title="0">{
                        exitCode = cmd.ProcessState.ExitCode()
                }</span>
                
                // Command execution failures are not retryable because:
                // - Script logic errors won't be fixed by retrying
                // - Non-zero exit codes indicate the script ran but failed
                // - Retrying could cause duplicate side effects (notifications, file writes)
                // Context includes execution metrics for performance analysis
                <span class="cov0" title="0">return errors.New(err).
                        Component("analysis.processor").
                        Category(errors.CategoryCommandExecution).
                        Context("operation", "execute_command").
                        Context("execution_duration_ms", executionDuration.Milliseconds()).
                        Context("exit_code", exitCode).
                        Context("output_size_bytes", len(output)).
                        Context("retryable", false). // Command execution failures are typically not retryable
                        Build()</span>
        }

        // Log command success with size and truncated preview to avoid excessive log size
        <span class="cov0" title="0">outputStr := string(output)
        preview := outputStr
        if len(outputStr) &gt; 200 </span><span class="cov0" title="0">{
                preview = outputStr[:200] + "... (truncated)"
        }</span>
        <span class="cov0" title="0">logger.Info("Command executed successfully", 
                "output_size_bytes", len(output),
                "execution_duration_ms", executionDuration.Milliseconds(),
                "output_preview", preview)
        return nil</span>
}

// validateCommandPath ensures the command exists and is executable
func validateCommandPath(command string) (string, error) <span class="cov0" title="0">{
        // Clean the path to remove any potential directory traversal
        command = filepath.Clean(command)

        // Check if it's an absolute path
        if !filepath.IsAbs(command) </span><span class="cov0" title="0">{
                return "", errors.Newf("command must use absolute path").
                        Component("analysis.processor").
                        Category(errors.CategoryValidation).
                        Context("operation", "validate_command_path").
                        Context("security_check", "absolute_path_required").
                        Context("path_classification", "relative_path").
                        Context("validation_rule", "absolute_paths_only").
                        Context("retryable", false). // Path validation failure is permanent
                        Build()
        }</span>

        // Verify the file exists and is executable
        <span class="cov0" title="0">info, err := os.Stat(command)
        if err != nil </span><span class="cov0" title="0">{
                // Classify OS errors for better telemetry and debugging
                // Using switch statement instead of if-else chain per gocritic best practices
                // This pattern provides clearer intent and better performance for multiple conditions
                var classification string
                switch </span>{
                case os.IsNotExist(err):<span class="cov0" title="0">
                        classification = "file_not_found"</span>
                case os.IsPermission(err):<span class="cov0" title="0">
                        classification = "permission_denied"</span>
                default:<span class="cov0" title="0">
                        classification = "file_access_error"</span>
                }
                
                // File system errors are not retryable as they indicate permanent issues:
                // - Missing files won't suddenly appear
                // - Permission denials require manual intervention
                // - Other file access errors typically indicate corruption or system issues
                <span class="cov0" title="0">return "", errors.New(err).
                        Component("analysis.processor").
                        Category(errors.CategoryFileIO).
                        Context("operation", "validate_command_path").
                        Context("security_check", "file_existence").
                        Context("error_classification", classification).
                        Context("retryable", false). // File existence issues are permanent
                        Build()</span>
        }

        // Check file permissions
        <span class="cov0" title="0">if runtime.GOOS != "windows" </span><span class="cov0" title="0">{
                if info.Mode()&amp;0o111 == 0 </span><span class="cov0" title="0">{
                        return "", errors.Newf("command is not executable").
                                Component("analysis.processor").
                                Category(errors.CategoryValidation).
                                Context("operation", "validate_command_path").
                                Context("security_check", "executable_permission").
                                Context("file_mode", info.Mode().String()).
                                Context("os_platform", runtime.GOOS).
                                Context("retryable", false). // Permission issues are permanent
                                Build()
                }</span>
        }

        <span class="cov0" title="0">return command, nil</span>
}

// buildSafeArguments creates a sanitized list of command arguments
func buildSafeArguments(params map[string]any, note *datastore.Note) ([]string, error) <span class="cov0" title="0">{
        // Pre-allocate slice with capacity for all parameters
        args := make([]string, 0, len(params))

        // Get sorted keys for deterministic CLI argument order
        keys := make([]string, 0, len(params))
        for key := range params </span><span class="cov0" title="0">{
                keys = append(keys, key)
        }</span>
        <span class="cov0" title="0">slices.Sort(keys)

        for _, key := range keys </span><span class="cov0" title="0">{
                value := params[key]
                
                // Validate parameter name (allow only alphanumeric and _-)
                if !isValidParamName(key) </span><span class="cov0" title="0">{
                        return nil, errors.Newf("invalid parameter name").
                                Component("analysis.processor").
                                Category(errors.CategoryValidation).
                                Context("operation", "build_command_arguments").
                                Context("security_check", "parameter_name_validation").
                                Context("validation_rule", "alphanumeric_underscore_dash_only").
                                Context("param_name", key).
                                Context("retryable", false). // Parameter validation failure is permanent
                                Build()
                }</span>

                // Get value from Note or use default
                <span class="cov0" title="0">noteValue := getNoteValueByName(note, key)
                if noteValue == nil </span><span class="cov0" title="0">{
                        noteValue = value
                }</span>

                // Convert and validate the value
                <span class="cov0" title="0">strValue, err := sanitizeValue(noteValue)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.New(err).
                                Component("analysis.processor").
                                Category(errors.CategoryValidation).
                                Context("operation", "build_command_arguments").
                                Context("security_check", "value_sanitization").
                                Context("value_type", fmt.Sprintf("%T", noteValue)).
                                Context("param_name", key).
                                Context("retryable", false). // Value sanitization failure is permanent
                                Build()
                }</span>

                // Handle quoting for values that need it
                <span class="cov0" title="0">if strings.ContainsAny(strValue, " @\"'") </span><span class="cov0" title="0">{
                        // Check if already quoted to avoid double quoting
                        if !strings.HasPrefix(strValue, "\"") || !strings.HasSuffix(strValue, "\"") </span><span class="cov0" title="0">{
                                // Use %q for proper quoting (handles escaping automatically)
                                strValue = fmt.Sprintf("%q", strValue)
                        }</span>
                }

                <span class="cov0" title="0">arg := fmt.Sprintf("--%s=%s", key, strValue)
                args = append(args, arg)</span>
        }

        <span class="cov0" title="0">return args, nil</span>
}

// isValidParamName checks if a parameter name contains only safe characters
func isValidParamName(name string) bool <span class="cov0" title="0">{
        for _, r := range name </span><span class="cov0" title="0">{
                if (r &lt; 'a' || r &gt; 'z') &amp;&amp; (r &lt; 'A' || r &gt; 'Z') &amp;&amp;
                        (r &lt; '0' || r &gt; '9') &amp;&amp; r != '_' &amp;&amp; r != '-' </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov0" title="0">return true</span>
}

// sanitizeValue converts and validates a value to string
func sanitizeValue(value any) (string, error) <span class="cov0" title="0">{
        // Convert to string and validate
        str := fmt.Sprintf("%v", value)

        // Basic sanitization - remove any control characters
        str = strings.Map(func(r rune) rune </span><span class="cov0" title="0">{
                if r &lt; 32 </span><span class="cov0" title="0">{
                        return -1
                }</span>
                <span class="cov0" title="0">return r</span>
        }, str)

        // Additional validation can be added here

        <span class="cov0" title="0">return str, nil</span>
}

// getCleanEnvironment returns a minimal set of necessary environment variables
func getCleanEnvironment() []string <span class="cov0" title="0">{
        // Provide only necessary environment variables
        env := []string{
                "PATH=" + os.Getenv("PATH"),
                "TEMP=" + os.Getenv("TEMP"),
                "TMP=" + os.Getenv("TMP"),
        }

        // Add system root for Windows
        if runtime.GOOS == "windows" </span><span class="cov0" title="0">{
                env = append(env, "SystemRoot="+os.Getenv("SystemRoot"))
        }</span>

        <span class="cov0" title="0">return env</span>
}

// getNoteValueByName retrieves a value from a Note by field name using reflection
func getNoteValueByName(note *datastore.Note, paramName string) any <span class="cov0" title="0">{
        val := reflect.ValueOf(*note)
        fieldVal := val.FieldByName(paramName)

        // Check if the field is valid (exists in the struct) and can be interfaced
        if fieldVal.IsValid() &amp;&amp; fieldVal.CanInterface() </span><span class="cov0" title="0">{
                return fieldVal.Interface()
        }</span>

        // Return nil or an appropriate zero value if the field does not exist
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">// jobqueue_adapter.go provides adapter functions for using the jobqueue package
//
// This file contains only the essential ActionAdapter component for interfacing
// with the jobqueue package.
package processor

// ActionAdapter adapts the processor.Action interface to the jobqueue.Action interface
type ActionAdapter struct {
        action Action
}

// Execute implements the jobqueue.Action interface
func (a *ActionAdapter) Execute(data interface{}) error <span class="cov0" title="0">{
        return a.action.Execute(data)
}</span>

// GetDescription returns a human-readable description of the action
func (a *ActionAdapter) GetDescription() string <span class="cov0" title="0">{
        return a.action.GetDescription()
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">// log_deduplicator.go
package processor

import (
        "sync"
        "time"
)

// LogState tracks the last logged state for a source to prevent duplicate logging
type LogState struct {
        LastRawCount      int       // Last logged raw results count
        LastFilteredCount int       // Last logged filtered detections count
        LastLogTime       time.Time // Last time we logged for this source
}

// LogDeduplicator handles intelligent log deduplication for high-frequency messages.
// It prevents repetitive logging while maintaining observability through periodic
// health checks and state change detection.
type LogDeduplicator struct {
        states map[string]*LogState
        mu     sync.RWMutex
        config DeduplicationConfig
}

// DeduplicationConfig controls deduplication behavior
type DeduplicationConfig struct {
        HealthCheckInterval time.Duration // How often to log even if no changes
        Enabled             bool          // Whether deduplication is enabled
}

// NewLogDeduplicator creates a new deduplicator with the given configuration
func NewLogDeduplicator(config DeduplicationConfig) *LogDeduplicator <span class="cov0" title="0">{
        // Set default health check interval if not specified
        if config.HealthCheckInterval == 0 </span><span class="cov0" title="0">{
                config.HealthCheckInterval = 60 * time.Second
        }</span>
        
        <span class="cov0" title="0">return &amp;LogDeduplicator{
                states: make(map[string]*LogState),
                config: config,
        }</span>
}

// ShouldLog determines if a message should be logged based on deduplication rules.
// It returns whether to log and the reason for logging.
// Reasons include: "dedup_disabled", "first_log", "values_changed", "health_check"
func (d *LogDeduplicator) ShouldLog(source string, rawCount, filteredCount int) (shouldLog bool, reason string) <span class="cov0" title="0">{
        // If deduplication is disabled, always log
        if !d.config.Enabled </span><span class="cov0" title="0">{
                return true, "dedup_disabled"
        }</span>
        
        <span class="cov0" title="0">d.mu.Lock()
        defer d.mu.Unlock()
        
        now := time.Now()
        state, exists := d.states[source]
        
        // First time seeing this source
        if !exists </span><span class="cov0" title="0">{
                d.states[source] = &amp;LogState{
                        LastRawCount:      rawCount,
                        LastFilteredCount: filteredCount,
                        LastLogTime:       now,
                }
                return true, "first_log"
        }</span>
        
        // Check if values changed
        <span class="cov0" title="0">if state.LastRawCount != rawCount || state.LastFilteredCount != filteredCount </span><span class="cov0" title="0">{
                state.LastRawCount = rawCount
                state.LastFilteredCount = filteredCount
                state.LastLogTime = now
                return true, "values_changed"
        }</span>
        
        // Check if it's time for a health check
        <span class="cov0" title="0">if now.Sub(state.LastLogTime) &gt;= d.config.HealthCheckInterval </span><span class="cov0" title="0">{
                state.LastLogTime = now
                return true, "health_check"
        }</span>
        
        // No need to log - it's a duplicate
        <span class="cov0" title="0">return false, ""</span>
}

// Cleanup removes stale entries to prevent unbounded memory growth.
// Call this periodically (e.g., hourly) to remove sources that haven't
// been seen for longer than staleAfter duration.
func (d *LogDeduplicator) Cleanup(staleAfter time.Duration) int <span class="cov0" title="0">{
        d.mu.Lock()
        defer d.mu.Unlock()
        
        cutoff := time.Now().Add(-staleAfter)
        removed := 0
        
        for source, state := range d.states </span><span class="cov0" title="0">{
                if state.LastLogTime.Before(cutoff) </span><span class="cov0" title="0">{
                        delete(d.states, source)
                        removed++
                }</span>
        }
        
        <span class="cov0" title="0">return removed</span>
}

// Reset clears all deduplication state
func (d *LogDeduplicator) Reset() <span class="cov0" title="0">{
        d.mu.Lock()
        defer d.mu.Unlock()
        
        d.states = make(map[string]*LogState)
}</span>

// Stats returns current deduplication statistics
func (d *LogDeduplicator) Stats() (sourceCount int, enabled bool) <span class="cov0" title="0">{
        d.mu.RLock()
        defer d.mu.RUnlock()
        
        return len(d.states), d.config.Enabled
}</pre>
		
		<pre class="file" id="file7" style="display: none">// Package processor provides documentation for the processor package logging
package processor

import (
        "log"
        "log/slog"
        "os"
        "path/filepath"
        "sync"
        
        "github.com/tphakala/birdnet-go/internal/logging"
)

// Service name constant for the processor package
const serviceName = "analysis.processor"

var (
        processorLogger     *slog.Logger
        processorLoggerOnce sync.Once
        processorLevelVar   = new(slog.LevelVar) // Dynamic level control
        processorCloseFunc  func() error
)

func init() <span class="cov8" title="1">{
        var err error
        // Define log file path for processor operations
        logFilePath := filepath.Join("logs", "analysis-processor.log")
        initialLevel := slog.LevelInfo // Default to Info level
        processorLevelVar.Set(initialLevel)
        
        // Initialize the processor-specific file logger
        processorLogger, processorCloseFunc, err = logging.NewFileLogger(logFilePath, serviceName, processorLevelVar)
        if err != nil </span><span class="cov0" title="0">{
                // Fallback: Log error to standard log and use console logging
                log.Printf("Failed to initialize processor file logger at %s: %v. Using console logging.", logFilePath, err)
                // Set logger to console handler for actual console output
                fbHandler := slog.NewJSONHandler(os.Stderr, &amp;slog.HandlerOptions{Level: processorLevelVar})
                processorLogger = slog.New(fbHandler).With("service", serviceName)
                processorCloseFunc = func() error </span><span class="cov0" title="0">{ return nil }</span> // No-op closer
        }
}

// GetLogger returns the processor package logger
// This provides a uniform API for accessing the logger across packages.
// Note: The species tracker has its own dedicated logger in new_species_tracker.go
func GetLogger() *slog.Logger <span class="cov0" title="0">{
        processorLoggerOnce.Do(func() </span><span class="cov0" title="0">{
                if processorLogger == nil </span><span class="cov0" title="0">{
                        processorLogger = slog.Default().With("service", serviceName)
                }</span>
        })
        <span class="cov0" title="0">return processorLogger</span>
}

// CloseProcessorLogger closes the processor log file and releases resources
func CloseProcessorLogger() error <span class="cov0" title="0">{
        if processorCloseFunc != nil </span><span class="cov0" title="0">{
                return processorCloseFunc()
        }</span>
        <span class="cov0" title="0">return nil</span>
}</pre>
		
		<pre class="file" id="file8" style="display: none">// mqtt.go: MQTT-related functionality for the processor
package processor

import (
        "context"
        "fmt"
        "time"

        "github.com/tphakala/birdnet-go/internal/conf"
        "github.com/tphakala/birdnet-go/internal/mqtt"
)

// GetMQTTClient safely returns the current MQTT client
func (p *Processor) GetMQTTClient() mqtt.Client <span class="cov0" title="0">{
        p.mqttMutex.RLock()
        defer p.mqttMutex.RUnlock()
        return p.MqttClient
}</span>

// SetMQTTClient safely sets a new MQTT client
func (p *Processor) SetMQTTClient(client mqtt.Client) <span class="cov0" title="0">{
        p.mqttMutex.Lock()
        defer p.mqttMutex.Unlock()
        p.MqttClient = client
}</span>

// DisconnectMQTTClient safely disconnects and removes the MQTT client
func (p *Processor) DisconnectMQTTClient() <span class="cov0" title="0">{
        p.mqttMutex.Lock()
        defer p.mqttMutex.Unlock()
        if p.MqttClient != nil </span><span class="cov0" title="0">{
                p.MqttClient.Disconnect()
                p.MqttClient = nil
        }</span>
}

// PublishMQTT safely publishes a message using the MQTT client if available
func (p *Processor) PublishMQTT(ctx context.Context, topic, payload string) error <span class="cov0" title="0">{
        p.mqttMutex.RLock()
        client := p.MqttClient
        p.mqttMutex.RUnlock()

        if client != nil &amp;&amp; client.IsConnected() </span><span class="cov0" title="0">{
                return client.Publish(ctx, topic, payload)
        }</span>
        <span class="cov0" title="0">return fmt.Errorf("MQTT client not available or not connected")</span>
}

// initializeMQTT initializes the MQTT client if enabled in settings
func (p *Processor) initializeMQTT(settings *conf.Settings) <span class="cov0" title="0">{
        if !settings.Realtime.MQTT.Enabled </span><span class="cov0" title="0">{
                return
        }</span>

        // Create a new MQTT client using the settings and metrics
        <span class="cov0" title="0">mqttClient, err := mqtt.NewClient(settings, p.Metrics)
        if err != nil </span><span class="cov0" title="0">{
                // Log an error if client creation fails
                logger := GetLogger()
                logger.Error("Failed to create MQTT client", "error", err)
                return
        }</span>

        // Create a context with a 30-second timeout for the connection attempt
        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
        defer cancel() // Ensure the cancel function is called to release resources

        // Attempt to connect to the MQTT broker
        if err := mqttClient.Connect(ctx); err != nil </span><span class="cov0" title="0">{
                // Log an error if the connection attempt fails
                logger := GetLogger()
                logger.Error("Failed to connect to MQTT broker", "error", err)
                return
        }</span>

        // Set the client only if connection was successful
        <span class="cov0" title="0">p.SetMQTTClient(mqttClient)</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">// new_species_tracker.go
package processor

import (
        "log/slog"
        "sync"
        "time"

        "github.com/tphakala/birdnet-go/internal/conf"
        "github.com/tphakala/birdnet-go/internal/datastore"
        "github.com/tphakala/birdnet-go/internal/errors"
        "github.com/tphakala/birdnet-go/internal/logging"
)

// Constants for better maintainability and avoiding magic numbers
const (
        // Cache configuration
        defaultCacheTTL        = 30 * time.Second // Status cache TTL
        defaultSeasonCacheTTL  = time.Hour        // Season cache TTL
        defaultCacheExpiredAge = -time.Hour       // Age for marking cache as expired

        // Capacity hints for map allocations
        initialSpeciesCapacity = 100 // Initial capacity for species maps

        // Time calculations
        hoursPerDay               = 24
        seasonBufferDays          = 7 // Days buffer for season comparison
        seasonBufferDuration      = seasonBufferDays * hoursPerDay * time.Hour
        defaultSeasonDurationDays = 90 // Typical season duration

        // Season calculations
        winterAdjustmentCutoffMonth time.Month = time.June // June - first month where winter shouldn't adjust to previous year

        // Notification suppression
        defaultNotificationSuppressionWindow = 168 * time.Hour // Default suppression window (7 days)
)

// Package-level logger for species tracking
var (
        logger          *slog.Logger
        serviceLevelVar = new(slog.LevelVar) // Dynamic level control
        closeLogger     func() error
)

func init() <span class="cov8" title="1">{
        // Initialize species tracking logger
        // This creates a dedicated log file at logs/species-tracking.log
        var err error

        // Set initial level to Debug for comprehensive logging
        serviceLevelVar.Set(slog.LevelDebug)

        logger, closeLogger, err = logging.NewFileLogger(
                "logs/species-tracking.log",
                "species-tracking",
                serviceLevelVar,
        )

        if err != nil || logger == nil </span><span class="cov0" title="0">{
                // Fallback to default logger if file logger creation fails
                logger = slog.Default().With("service", "species-tracking")
                closeLogger = func() error </span><span class="cov0" title="0">{ return nil }</span>
                // Log the error so we know why the file logger failed
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        logger.Error("Failed to initialize species tracking file logger", "error", err)
                }</span>
        }
}

// Close releases the file logger resources to prevent resource leaks.
// This should be called during application shutdown or when the logger is no longer needed.
func Close() error <span class="cov0" title="0">{
        if closeLogger != nil </span><span class="cov0" title="0">{
                return closeLogger()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// SpeciesDatastore defines the minimal interface needed by NewSpeciesTracker
type SpeciesDatastore interface {
        GetNewSpeciesDetections(startDate, endDate string, limit, offset int) ([]datastore.NewSpeciesData, error)
        GetSpeciesFirstDetectionInPeriod(startDate, endDate string, limit, offset int) ([]datastore.NewSpeciesData, error)
}

// SpeciesStatus represents the tracking status of a species across multiple periods
type SpeciesStatus struct {
        // Existing lifetime tracking
        FirstSeenTime   time.Time
        IsNew           bool
        DaysSinceFirst  int
        LastUpdatedTime time.Time // For cache management

        // Multi-period tracking
        FirstThisYear   *time.Time // First detection this calendar year
        FirstThisSeason *time.Time // First detection this season
        CurrentSeason   string     // Current season name

        // Status flags for each period
        IsNewThisYear   bool // First time this year
        IsNewThisSeason bool // First time this season
        DaysThisYear    int  // Days since first this year
        DaysThisSeason  int  // Days since first this season
}

// cachedSpeciesStatus represents a cached species status result with timestamp
type cachedSpeciesStatus struct {
        status    SpeciesStatus
        timestamp time.Time
}

// NewSpeciesTracker tracks species detections and identifies new species
// within a configurable time window. Designed for minimal memory allocations.
type NewSpeciesTracker struct {
        mu sync.RWMutex

        // Lifetime tracking (existing)
        speciesFirstSeen map[string]time.Time // scientificName -&gt; first detection time
        windowDays       int                  // Days to consider a species "new"

        // Multi-period tracking
        speciesThisYear map[string]time.Time            // scientificName -&gt; first detection this year
        speciesBySeason map[string]map[string]time.Time // season -&gt; scientificName -&gt; first detection time
        currentYear     int
        currentSeason   string
        seasons         map[string]seasonDates // season name -&gt; start dates

        // Configuration
        ds                 SpeciesDatastore
        lastSyncTime       time.Time
        syncIntervalMins   int
        yearlyEnabled      bool
        seasonalEnabled    bool
        yearlyWindowDays   int
        seasonalWindowDays int
        resetMonth         int // Month to reset yearly tracking (1-12)
        resetDay           int // Day to reset yearly tracking (1-31)

        // Pre-allocated for efficiency
        statusBuffer SpeciesStatus // Reusable buffer for status calculations

        // Status result caching for performance optimization
        statusCache      map[string]cachedSpeciesStatus // scientificName -&gt; cached status with TTL
        cacheTTL         time.Duration                  // Time-to-live for cached results
        lastCacheCleanup time.Time                      // Last time cache cleanup was performed

        // Season calculation caching for performance optimization
        cachedSeason       string        // Cached current season name
        seasonCacheTime    time.Time     // Timestamp when season was cached
        seasonCacheForTime time.Time     // The input time for which season was cached
        seasonCacheTTL     time.Duration // Time-to-live for season cache (1 hour)

        // Notification suppression tracking to prevent duplicate notifications
        // Simply maps scientific name -&gt; last notification time
        notificationLastSent          map[string]time.Time
        notificationSuppressionWindow time.Duration // Duration to suppress duplicate notifications (default: 7 days)
}

// seasonDates represents the start date for a season
type seasonDates struct {
        month int
        day   int
}

// NewSpeciesTrackerFromSettings creates a tracker from configuration settings
// Note: All time calculations use the system's local timezone via time.Now()
func NewSpeciesTrackerFromSettings(ds SpeciesDatastore, settings *conf.SpeciesTrackingSettings) *NewSpeciesTracker <span class="cov8" title="1">{
        now := time.Now() // Uses system local timezone

        // Log initialization
        logger.Debug("Creating new species tracker",
                "enabled", settings.Enabled,
                "window_days", settings.NewSpeciesWindowDays,
                "yearly_enabled", settings.YearlyTracking.Enabled,
                "seasonal_enabled", settings.SeasonalTracking.Enabled,
                "current_time", now.Format("2006-01-02 15:04:05"))

        tracker := &amp;NewSpeciesTracker{
                // Lifetime tracking
                speciesFirstSeen: make(map[string]time.Time, initialSpeciesCapacity),
                windowDays:       settings.NewSpeciesWindowDays,

                // Multi-period tracking
                speciesThisYear: make(map[string]time.Time, initialSpeciesCapacity),
                speciesBySeason: make(map[string]map[string]time.Time),
                currentYear:     now.Year(),
                seasons:         make(map[string]seasonDates),

                // Configuration
                ds:                 ds,
                syncIntervalMins:   settings.SyncIntervalMinutes,
                yearlyEnabled:      settings.YearlyTracking.Enabled,
                seasonalEnabled:    settings.SeasonalTracking.Enabled,
                yearlyWindowDays:   settings.YearlyTracking.WindowDays,
                seasonalWindowDays: settings.SeasonalTracking.WindowDays,
                resetMonth:         settings.YearlyTracking.ResetMonth,
                resetDay:           settings.YearlyTracking.ResetDay,

                // Status result caching
                statusCache:      make(map[string]cachedSpeciesStatus, initialSpeciesCapacity), // Pre-allocate for species
                cacheTTL:         defaultCacheTTL,                                              // TTL for cached results
                lastCacheCleanup: now,

                // Season calculation caching
                seasonCacheTTL: defaultSeasonCacheTTL, // TTL for season cache

                // Notification suppression tracking
                notificationLastSent: make(map[string]time.Time, initialSpeciesCapacity),
        }

        // Initialize seasons from configuration
        if settings.SeasonalTracking.Enabled &amp;&amp; len(settings.SeasonalTracking.Seasons) &gt; 0 </span><span class="cov8" title="1">{
                for name, season := range settings.SeasonalTracking.Seasons </span><span class="cov8" title="1">{
                        tracker.seasons[name] = seasonDates{
                                month: season.StartMonth,
                                day:   season.StartDay,
                        }
                        logger.Debug("Configured season",
                                "name", name,
                                "start_month", season.StartMonth,
                                "start_day", season.StartDay)
                }</span>
        } else<span class="cov8" title="1"> {
                tracker.initializeDefaultSeasons()
        }</span>

        <span class="cov8" title="1">tracker.currentSeason = tracker.getCurrentSeason(now)

        logger.Debug("Species tracker initialized",
                "current_season", tracker.currentSeason,
                "current_year", tracker.currentYear,
                "total_seasons", len(tracker.seasons))

        // Set notification suppression window from configuration
        // 0 is valid (disabled), negative values get default
        if settings.NotificationSuppressionHours &lt; 0 </span><span class="cov0" title="0">{
                tracker.notificationSuppressionWindow = defaultNotificationSuppressionWindow
        }</span> else<span class="cov8" title="1"> {
                tracker.notificationSuppressionWindow = time.Duration(settings.NotificationSuppressionHours) * time.Hour
        }</span>

        <span class="cov8" title="1">return tracker</span>
}

// initializeDefaultSeasons sets up the default Northern Hemisphere seasons
func (t *NewSpeciesTracker) initializeDefaultSeasons() <span class="cov8" title="1">{
        t.seasons["spring"] = seasonDates{month: 3, day: 20}  // March 20
        t.seasons["summer"] = seasonDates{month: 6, day: 21}  // June 21
        t.seasons["fall"] = seasonDates{month: 9, day: 22}    // September 22
        t.seasons["winter"] = seasonDates{month: 12, day: 21} // December 21
}</span>

// shouldAdjustWinter adjusts the season start year only when the season month is December
// and the current month is before winterAdjustmentCutoffMonth (Jan-May)
func (t *NewSpeciesTracker) shouldAdjustWinter(now time.Time, seasonMonth time.Month) bool <span class="cov8" title="1">{
        return seasonMonth == time.December &amp;&amp; now.Month() &lt; winterAdjustmentCutoffMonth
}</span>

// SetCurrentYearForTesting sets the current year for testing purposes only.
//
// ⚠️  WARNING: THIS METHOD IS STRICTLY FOR TESTING AND SHOULD NEVER BE USED IN PRODUCTION CODE ⚠️
//
// This method bypasses the normal year tracking logic and directly manipulates the internal
// currentYear field, which can lead to:
// - Inconsistent tracking data between lifetime, yearly, and seasonal periods
// - Cache invalidation issues that may cause incorrect species status calculations
// - Data corruption if the year doesn't match the actual system time
// - Broken yearly reset logic that relies on time-based transitions
//
// Using this method in production code will result in unpredictable behavior and should be
// avoided at all costs. It exists solely to enable controlled testing scenarios where
// specific year boundaries need to be simulated.
//
// This method provides controlled access to the currentYear field for test scenarios only.
func (t *NewSpeciesTracker) SetCurrentYearForTesting(year int) <span class="cov0" title="0">{
        t.mu.Lock()
        defer t.mu.Unlock()
        t.currentYear = year
}</span>

// getCurrentSeason determines which season we're currently in with intelligent caching
func (t *NewSpeciesTracker) getCurrentSeason(currentTime time.Time) string <span class="cov8" title="1">{
        // Check cache first - if valid entry exists and the input time is reasonably close to cached time
        if t.cachedSeason != "" &amp;&amp;
                t.isSameSeasonPeriod(currentTime, t.seasonCacheForTime) &amp;&amp;
                time.Since(t.seasonCacheTime) &lt; t.seasonCacheTTL </span><span class="cov8" title="1">{
                // Cache hit - return cached season directly
                return t.cachedSeason
        }</span>

        // Cache miss or expired - compute fresh season
        <span class="cov8" title="1">season := t.computeCurrentSeason(currentTime)

        // Cache the computed result for future requests
        t.cachedSeason = season
        t.seasonCacheTime = time.Now()     // Cache time is when we computed it
        t.seasonCacheForTime = currentTime // Input time for which we computed

        return season</span>
}

// isSameSeasonPeriod checks if two times are likely in the same season period
// This helps avoid cache misses for times that are very close together
func (t *NewSpeciesTracker) isSameSeasonPeriod(time1, time2 time.Time) bool <span class="cov8" title="1">{
        // If times are in different years, they could be in different seasons
        if time1.Year() != time2.Year() </span><span class="cov0" title="0">{
                return false
        }</span>

        // If times are within the same day, they're definitely in the same season
        <span class="cov8" title="1">if time1.YearDay() == time2.YearDay() </span><span class="cov8" title="1">{
                return true
        }</span>

        // If times are within seasonBufferDays of each other, they're very likely in the same season
        // (seasons typically last ~defaultSeasonDurationDays days, so seasonBufferDays is a safe buffer)
        <span class="cov0" title="0">timeDiff := time1.Sub(time2)
        if timeDiff &lt; 0 </span><span class="cov0" title="0">{
                timeDiff = -timeDiff
        }</span>
        <span class="cov0" title="0">return timeDiff &lt; seasonBufferDuration</span>
}

// computeCurrentSeason performs the actual season calculation (moved from getCurrentSeason)
func (t *NewSpeciesTracker) computeCurrentSeason(currentTime time.Time) string <span class="cov8" title="1">{
        currentMonth := int(currentTime.Month())
        currentDay := currentTime.Day()

        // Log season calculation
        logger.Debug("Computing current season",
                "input_time", currentTime.Format("2006-01-02 15:04:05"),
                "current_month", currentMonth,
                "current_day", currentDay,
                "current_year", currentTime.Year())

        // Check seasons in a deterministic order to handle boundaries correctly
        // Order: winter, spring, summer, fall (in chronological order within a year)
        seasonOrder := []string{"winter", "spring", "summer", "fall"}
        
        // Find the most recent season start date
        var currentSeason string
        var latestDate time.Time

        for _, seasonName := range seasonOrder </span><span class="cov8" title="1">{
                seasonStart, exists := t.seasons[seasonName]
                if !exists </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Create a date for this year's season start
                <span class="cov8" title="1">seasonDate := time.Date(currentTime.Year(), time.Month(seasonStart.month), seasonStart.day, 0, 0, 0, 0, currentTime.Location())

                // Handle winter season that might start in previous year
                if t.shouldAdjustWinter(currentTime, time.Month(seasonStart.month)) </span><span class="cov0" title="0">{
                        seasonDate = time.Date(currentTime.Year()-1, time.Month(seasonStart.month), seasonStart.day, 0, 0, 0, 0, currentTime.Location())
                        logger.Debug("Adjusting winter season to previous year",
                                "season", seasonName,
                                "adjusted_date", seasonDate.Format("2006-01-02"))
                }</span>

                // Check if current date is on or after this season's start
                <span class="cov8" title="1">if currentTime.Equal(seasonDate) || currentTime.After(seasonDate) </span><span class="cov8" title="1">{
                        // Update if this is a more recent season start than what we have
                        if currentSeason == "" || seasonDate.After(latestDate) </span><span class="cov8" title="1">{
                                logger.Debug("Season match found",
                                        "season", seasonName,
                                        "start_date", seasonDate.Format("2006-01-02"),
                                        "is_current", currentTime.Equal(seasonDate) || currentTime.After(seasonDate))
                                currentSeason = seasonName
                                latestDate = seasonDate
                        }</span>
                }
        }

        // Default to winter if we couldn't determine the season
        <span class="cov8" title="1">if currentSeason == "" </span><span class="cov0" title="0">{
                currentSeason = "winter"
                logger.Debug("Defaulting to winter season - no match found")
        }</span>

        <span class="cov8" title="1">logger.Debug("Computed season result",
                "season", currentSeason,
                "season_start_date", latestDate.Format("2006-01-02"))

        return currentSeason</span>
}

// checkAndResetPeriods checks if we need to reset yearly or seasonal tracking
func (t *NewSpeciesTracker) checkAndResetPeriods(currentTime time.Time) <span class="cov8" title="1">{
        // Check for yearly reset
        if t.yearlyEnabled &amp;&amp; t.shouldResetYear(currentTime) </span><span class="cov0" title="0">{
                oldYear := t.currentYear
                t.speciesThisYear = make(map[string]time.Time)
                t.currentYear = currentTime.Year()
                // Clear status cache when year resets to ensure fresh calculations
                t.statusCache = make(map[string]cachedSpeciesStatus)
                logger.Debug("Reset yearly tracking",
                        "old_year", oldYear,
                        "new_year", t.currentYear,
                        "check_time", currentTime.Format("2006-01-02 15:04:05"))
        }</span>

        // Check for seasonal reset
        <span class="cov8" title="1">if t.seasonalEnabled </span><span class="cov8" title="1">{
                newSeason := t.getCurrentSeason(currentTime)
                if newSeason != t.currentSeason </span><span class="cov0" title="0">{
                        t.currentSeason = newSeason
                        // Initialize season map if it doesn't exist
                        if t.speciesBySeason[newSeason] == nil </span><span class="cov0" title="0">{
                                t.speciesBySeason[newSeason] = make(map[string]time.Time)
                        }</span>
                }
        }
}

// shouldResetYear determines if we should reset yearly tracking
func (t *NewSpeciesTracker) shouldResetYear(currentTime time.Time) bool <span class="cov8" title="1">{
        // Check if we've crossed the yearly reset date
        resetDate := time.Date(currentTime.Year(), time.Month(t.resetMonth), t.resetDay, 0, 0, 0, 0, currentTime.Location())

        // If current time is after reset date and we haven't reset for this year
        if currentTime.After(resetDate) &amp;&amp; currentTime.Year() &gt; t.currentYear </span><span class="cov0" title="0">{
                return true
        }</span>

        // Handle case where reset date hasn't occurred yet this year
        <span class="cov8" title="1">if currentTime.Year() &gt; t.currentYear </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov8" title="1">return false</span>
}

// InitFromDatabase populates the tracker from historical data
// This should be called once during initialization
func (t *NewSpeciesTracker) InitFromDatabase() error <span class="cov8" title="1">{
        if t.ds == nil </span><span class="cov0" title="0">{
                return errors.Newf("datastore is nil").
                        Component("new-species-tracker").
                        Category(errors.CategoryConfiguration).
                        Build()
        }</span>

        <span class="cov8" title="1">now := time.Now()

        logger.Debug("Initializing species tracker from database",
                "current_time", now.Format("2006-01-02 15:04:05"),
                "yearly_enabled", t.yearlyEnabled,
                "seasonal_enabled", t.seasonalEnabled)

        t.mu.Lock()
        defer t.mu.Unlock()

        // Step 1: Load lifetime tracking data (existing logic)
        if err := t.loadLifetimeDataFromDatabase(now); err != nil </span><span class="cov0" title="0">{
                return errors.New(err).
                        Component("new-species-tracker").
                        Category(errors.CategoryDatabase).
                        Context("operation", "load_lifetime_data").
                        Context("sync_time", now.Format("2006-01-02 15:04:05")).
                        Build()
        }</span>

        // Step 2: Load yearly tracking data if enabled
        <span class="cov8" title="1">if t.yearlyEnabled </span><span class="cov8" title="1">{
                if err := t.loadYearlyDataFromDatabase(now); err != nil </span><span class="cov0" title="0">{
                        return errors.New(err).
                                Component("new-species-tracker").
                                Category(errors.CategoryDatabase).
                                Context("operation", "load_yearly_data").
                                Context("current_year", t.currentYear).
                                Build()
                }</span>
        }

        // Step 3: Load seasonal tracking data if enabled
        <span class="cov8" title="1">if t.seasonalEnabled </span><span class="cov8" title="1">{
                if err := t.loadSeasonalDataFromDatabase(now); err != nil </span><span class="cov0" title="0">{
                        return errors.New(err).
                                Component("new-species-tracker").
                                Category(errors.CategoryDatabase).
                                Context("operation", "load_seasonal_data").
                                Context("current_season", t.currentSeason).
                                Build()
                }</span>
        }

        <span class="cov8" title="1">t.lastSyncTime = now

        logger.Debug("Database initialization complete",
                "lifetime_species", len(t.speciesFirstSeen),
                "yearly_species", len(t.speciesThisYear),
                "total_seasons", len(t.speciesBySeason))

        return nil</span>
}

// loadLifetimeDataFromDatabase loads all-time first detection data
func (t *NewSpeciesTracker) loadLifetimeDataFromDatabase(now time.Time) error <span class="cov8" title="1">{
        endDate := now.Format("2006-01-02")
        startDate := "1900-01-01" // Load from beginning of time to get all historical data

        newSpeciesData, err := t.ds.GetNewSpeciesDetections(startDate, endDate, 10000, 0)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Newf("failed to load lifetime species data from database: %w", err).
                        Component("new-species-tracker").
                        Category(errors.CategoryDatabase).
                        Context("operation", "load_lifetime_data").
                        Context("start_date", startDate).
                        Context("end_date", endDate).
                        Build()
        }</span>

        // Only clear existing data if we have new data to replace it with
        // This prevents data loss if database returns empty results due to errors
        <span class="cov8" title="1">if len(newSpeciesData) &gt; 0 || len(t.speciesFirstSeen) == 0 </span><span class="cov8" title="1">{
                // Clear and populate lifetime tracking map
                t.speciesFirstSeen = make(map[string]time.Time, len(newSpeciesData))
                for _, species := range newSpeciesData </span><span class="cov8" title="1">{
                        if species.FirstSeenDate != "" </span><span class="cov8" title="1">{
                                firstSeen, err := time.Parse("2006-01-02", species.FirstSeenDate)
                                if err == nil </span><span class="cov8" title="1">{
                                        t.speciesFirstSeen[species.ScientificName] = firstSeen
                                }</span>
                        }
                }
        } else<span class="cov0" title="0"> {
                // Database returned empty data but we have existing data - keep it
                logger.Debug("Database returned empty species data, preserving existing tracking data",
                        "existing_species_count", len(t.speciesFirstSeen))
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// loadYearlyDataFromDatabase loads first detection data for the current year
func (t *NewSpeciesTracker) loadYearlyDataFromDatabase(now time.Time) error <span class="cov8" title="1">{
        startDate, endDate := t.getYearDateRange(now)

        // Use GetSpeciesFirstDetectionInPeriod for yearly tracking
        yearlyData, err := t.ds.GetSpeciesFirstDetectionInPeriod(startDate, endDate, 10000, 0)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Newf("failed to load yearly species data from database: %w", err).
                        Component("new-species-tracker").
                        Category(errors.CategoryDatabase).
                        Context("operation", "load_yearly_data").
                        Context("year_start", startDate).
                        Context("year_end", endDate).
                        Context("current_year", t.currentYear).
                        Build()
        }</span>

        // Only clear existing data if we have new data to replace it with
        // This prevents data loss if database returns empty results due to errors
        <span class="cov8" title="1">if len(yearlyData) &gt; 0 || len(t.speciesThisYear) == 0 </span><span class="cov8" title="1">{
                // Clear and populate yearly tracking map
                t.speciesThisYear = make(map[string]time.Time, len(yearlyData))
                for _, species := range yearlyData </span><span class="cov0" title="0">{
                        if species.FirstSeenDate != "" </span><span class="cov0" title="0">{
                                firstSeen, err := time.Parse("2006-01-02", species.FirstSeenDate)
                                if err == nil </span><span class="cov0" title="0">{
                                        t.speciesThisYear[species.ScientificName] = firstSeen
                                }</span>
                        }
                }
        } else<span class="cov0" title="0"> {
                // Database returned empty data but we have existing data - keep it
                logger.Debug("Database returned empty yearly data, preserving existing tracking data",
                        "existing_yearly_species_count", len(t.speciesThisYear),
                        "year", t.currentYear)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// loadSeasonalDataFromDatabase loads first detection data for each season in the current year
func (t *NewSpeciesTracker) loadSeasonalDataFromDatabase(now time.Time) error <span class="cov8" title="1">{
        // Preserve existing seasonal maps if we have them
        existingSeasonData := t.speciesBySeason
        hasExistingData := len(existingSeasonData) &gt; 0
        
        // Initialize seasonal maps
        t.speciesBySeason = make(map[string]map[string]time.Time)

        logger.Debug("Loading seasonal data from database",
                "total_seasons", len(t.seasons),
                "has_existing_data", hasExistingData)

        for seasonName := range t.seasons </span><span class="cov8" title="1">{
                startDate, endDate := t.getSeasonDateRange(seasonName, now)

                logger.Debug("Loading data for season",
                        "season", seasonName,
                        "start_date", startDate,
                        "end_date", endDate)

                // Get first detection of each species within this season period
                seasonalData, err := t.ds.GetSpeciesFirstDetectionInPeriod(startDate, endDate, 10000, 0)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.Newf("failed to load seasonal species data from database for %s: %w", seasonName, err).
                                Component("new-species-tracker").
                                Category(errors.CategoryDatabase).
                                Context("operation", "load_seasonal_data").
                                Context("season", seasonName).
                                Context("season_start", startDate).
                                Context("season_end", endDate).
                                Build()
                }</span>

                <span class="cov8" title="1">logger.Debug("Retrieved seasonal detections",
                        "season", seasonName,
                        "total_records", len(seasonalData))

                // Initialize season map
                seasonMap := make(map[string]time.Time, len(seasonalData))
                for _, species := range seasonalData </span><span class="cov0" title="0">{
                        if species.FirstSeenDate != "" </span><span class="cov0" title="0">{
                                firstSeen, err := time.Parse("2006-01-02", species.FirstSeenDate)
                                if err == nil </span><span class="cov0" title="0">{
                                        seasonMap[species.ScientificName] = firstSeen
                                        logger.Debug("Added species to season",
                                                "season", seasonName,
                                                "species", species.ScientificName,
                                                "first_seen", firstSeen.Format("2006-01-02"))
                                }</span>
                        }
                }
                <span class="cov8" title="1">t.speciesBySeason[seasonName] = seasonMap

                logger.Debug("Season loading complete",
                        "season", seasonName,
                        "total_retrieved", len(seasonalData),
                        "species_loaded", len(seasonMap))</span>
        }

        // Check if all seasons returned empty data
        <span class="cov8" title="1">allEmpty := true
        for _, seasonMap := range t.speciesBySeason </span><span class="cov8" title="1">{
                if len(seasonMap) &gt; 0 </span><span class="cov0" title="0">{
                        allEmpty = false
                        break</span>
                }
        }

        // If all seasons returned empty and we had existing data, restore it
        <span class="cov8" title="1">if allEmpty &amp;&amp; hasExistingData </span><span class="cov0" title="0">{
                logger.Debug("All seasons returned empty data, restoring existing seasonal tracking data")
                t.speciesBySeason = existingSeasonData
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// getYearDateRange calculates the start and end dates for yearly tracking
func (t *NewSpeciesTracker) getYearDateRange(now time.Time) (startDate, endDate string) <span class="cov8" title="1">{
        currentYear := now.Year()

        // Calculate year start based on reset settings
        yearStart := time.Date(currentYear, time.Month(t.resetMonth), t.resetDay, 0, 0, 0, 0, now.Location())

        // If we haven't reached the reset date this year, use last year's reset date
        if now.Before(yearStart) </span><span class="cov0" title="0">{
                yearStart = time.Date(currentYear-1, time.Month(t.resetMonth), t.resetDay, 0, 0, 0, 0, now.Location())
        }</span>

        <span class="cov8" title="1">startDate = yearStart.Format("2006-01-02")
        endDate = now.Format("2006-01-02")

        return startDate, endDate</span>
}

// getSeasonDateRange calculates the start and end dates for a specific season
func (t *NewSpeciesTracker) getSeasonDateRange(seasonName string, now time.Time) (startDate, endDate string) <span class="cov8" title="1">{
        season, exists := t.seasons[seasonName]
        if !exists </span><span class="cov0" title="0">{
                // Return empty range for unknown season
                return now.Format("2006-01-02"), now.Format("2006-01-02")
        }</span>

        <span class="cov8" title="1">currentYear := now.Year()

        // Calculate season start date for this year
        seasonStart := time.Date(currentYear, time.Month(season.month), season.day, 0, 0, 0, 0, now.Location())

        // Handle winter season that might start in previous year
        // Winter spans across years: Dec 21 (year X) -&gt; Mar 19 (year X+1)
        // This ensures consistency between season detection and date range calculations
        if t.shouldAdjustWinter(now, time.Month(season.month)) </span><span class="cov0" title="0">{
                seasonStart = time.Date(currentYear-1, time.Month(season.month), season.day, 0, 0, 0, 0, now.Location())
        }</span>

        // If the season hasn't started yet this year, don't return any data
        <span class="cov8" title="1">if now.Before(seasonStart) </span><span class="cov8" title="1">{
                return now.Format("2006-01-02"), now.Format("2006-01-02") // Empty range
        }</span>

        <span class="cov8" title="1">startDate = seasonStart.Format("2006-01-02")
        endDate = now.Format("2006-01-02")

        return startDate, endDate</span>
}

// isWithinCurrentYear checks if a detection time falls within the current tracking year
func (t *NewSpeciesTracker) isWithinCurrentYear(detectionTime time.Time) bool <span class="cov8" title="1">{
        // Use the tracker's current year (respects SetCurrentYearForTesting)
        // UTC is used here only for creating a reference point - actual comparisons use local time
        referenceTime := time.Date(t.currentYear, time.December, 31, 23, 59, 59, 0, time.UTC)
        startDate, _ := t.getYearDateRange(referenceTime)
        yearStart, err := time.Parse("2006-01-02", startDate)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // Check if the detection falls within this year's tracking period
        <span class="cov8" title="1">return detectionTime.After(yearStart) || detectionTime.Equal(yearStart)</span>
}

// GetSpeciesStatus returns the tracking status for a species with caching for performance
// This method implements cache-first lookup with TTL validation to minimize expensive computations
func (t *NewSpeciesTracker) GetSpeciesStatus(scientificName string, currentTime time.Time) SpeciesStatus <span class="cov8" title="1">{
        t.mu.Lock()
        defer t.mu.Unlock()

        // Check cache first - if valid entry exists within TTL, return it
        if cached, exists := t.statusCache[scientificName]; exists </span><span class="cov8" title="1">{
                if currentTime.Sub(cached.timestamp) &lt; t.cacheTTL </span><span class="cov8" title="1">{
                        // Cache hit - return cached result directly
                        return cached.status
                }</span>
                // Cache expired - will recompute and update cache below
        }

        // Perform periodic cache cleanup to prevent unbounded growth
        <span class="cov8" title="1">if currentTime.Sub(t.lastCacheCleanup) &gt; t.cacheTTL*10 </span><span class="cov0" title="0">{ // Cleanup every 10 TTL periods (5 minutes)
                t.cleanupExpiredCache(currentTime)
                t.lastCacheCleanup = currentTime
        }</span>

        // Cache miss or expired - compute fresh status
        <span class="cov8" title="1">t.checkAndResetPeriods(currentTime)
        currentSeason := t.getCurrentSeason(currentTime)

        // Build fresh status using the same logic as buildSpeciesStatusLocked but with buffer reuse
        status := t.buildSpeciesStatusWithBuffer(scientificName, currentTime, currentSeason)

        firstSeenStr := "never"
        if !status.FirstSeenTime.IsZero() </span><span class="cov8" title="1">{
                firstSeenStr = status.FirstSeenTime.Format("2006-01-02")
        }</span>

        <span class="cov8" title="1">firstThisYearStr := "nil"
        if status.FirstThisYear != nil </span><span class="cov8" title="1">{
                firstThisYearStr = status.FirstThisYear.Format("2006-01-02")
        }</span>

        <span class="cov8" title="1">firstThisSeasonStr := "nil"
        if status.FirstThisSeason != nil </span><span class="cov8" title="1">{
                firstThisSeasonStr = status.FirstThisSeason.Format("2006-01-02")
        }</span>

        <span class="cov8" title="1">logger.Debug("Species status computed",
                "species", scientificName,
                "current_time", currentTime.Format("2006-01-02 15:04:05"),
                "current_season", currentSeason,
                "is_new", status.IsNew,
                "is_new_this_year", status.IsNewThisYear,
                "is_new_this_season", status.IsNewThisSeason,
                "days_since_first", status.DaysSinceFirst,
                "days_this_year", status.DaysThisYear,
                "days_this_season", status.DaysThisSeason,
                "first_seen", firstSeenStr,
                "first_this_year", firstThisYearStr,
                "first_this_season", firstThisSeasonStr)

        // Cache the computed result for future requests
        t.statusCache[scientificName] = cachedSpeciesStatus{
                status:    status,
                timestamp: currentTime,
        }

        return status</span>
}

// buildSpeciesStatusWithBuffer builds species status reusing the pre-allocated buffer
// This method is used by GetSpeciesStatus to maintain the buffer optimization
func (t *NewSpeciesTracker) buildSpeciesStatusWithBuffer(scientificName string, currentTime time.Time, currentSeason string) SpeciesStatus <span class="cov8" title="1">{
        // Lifetime tracking
        firstSeen, exists := t.speciesFirstSeen[scientificName]

        // Yearly tracking
        var firstThisYear *time.Time
        if t.yearlyEnabled </span><span class="cov8" title="1">{
                if yearTime, yearExists := t.speciesThisYear[scientificName]; yearExists </span><span class="cov8" title="1">{
                        // Create a copy to avoid pointer to loop variable issue
                        timeCopy := yearTime
                        firstThisYear = &amp;timeCopy
                }</span>
        }

        // Seasonal tracking - check current season only (matches original behavior)
        <span class="cov8" title="1">var firstThisSeason *time.Time
        if t.seasonalEnabled &amp;&amp; t.speciesBySeason[currentSeason] != nil </span><span class="cov8" title="1">{
                if seasonTime, seasonExists := t.speciesBySeason[currentSeason][scientificName]; seasonExists </span><span class="cov8" title="1">{
                        // Create a copy to avoid pointer to loop variable issue
                        timeCopy := seasonTime
                        firstThisSeason = &amp;timeCopy
                }</span>
        }

        // Reuse the pre-allocated status buffer
        <span class="cov8" title="1">status := &amp;t.statusBuffer
        status.FirstSeenTime = firstSeen
        status.IsNew = false
        status.DaysSinceFirst = -1
        status.LastUpdatedTime = currentTime
        status.FirstThisYear = firstThisYear
        status.FirstThisSeason = firstThisSeason
        status.CurrentSeason = currentSeason
        status.IsNewThisYear = false
        status.IsNewThisSeason = false
        status.DaysThisYear = -1
        status.DaysThisSeason = -1

        // Calculate lifetime status
        if exists </span><span class="cov8" title="1">{
                daysSince := int(currentTime.Sub(firstSeen).Hours() / hoursPerDay)
                status.DaysSinceFirst = daysSince
                status.IsNew = daysSince &lt;= t.windowDays
        }</span> else<span class="cov8" title="1"> {
                // Species not seen before
                status.IsNew = true
                status.DaysSinceFirst = 0
        }</span>

        // Calculate yearly status
        <span class="cov8" title="1">if t.yearlyEnabled </span><span class="cov8" title="1">{
                if firstThisYear != nil </span><span class="cov8" title="1">{
                        daysThisYear := int(currentTime.Sub(*firstThisYear).Hours() / hoursPerDay)
                        status.DaysThisYear = daysThisYear
                        status.IsNewThisYear = daysThisYear &lt;= t.yearlyWindowDays
                }</span> else<span class="cov0" title="0"> {
                        // First time this year
                        status.IsNewThisYear = true
                        status.DaysThisYear = 0
                }</span>
        }

        // Calculate seasonal status
        <span class="cov8" title="1">if t.seasonalEnabled </span><span class="cov8" title="1">{
                if firstThisSeason != nil </span><span class="cov8" title="1">{
                        daysThisSeason := int(currentTime.Sub(*firstThisSeason).Hours() / hoursPerDay)
                        status.DaysThisSeason = daysThisSeason
                        status.IsNewThisSeason = daysThisSeason &lt;= t.seasonalWindowDays
                }</span> else<span class="cov0" title="0"> {
                        // First time this season
                        status.IsNewThisSeason = true
                        status.DaysThisSeason = 0
                }</span>
        }

        <span class="cov8" title="1">return *status</span>
}

// cleanupExpiredCache removes expired entries from the status cache to prevent memory leaks
// cleanupExpiredCache removes expired entries and enforces size limits with LRU eviction
func (t *NewSpeciesTracker) cleanupExpiredCache(currentTime time.Time) <span class="cov0" title="0">{
        const maxStatusCacheSize = 1000 // Maximum number of species to cache

        // First pass: remove expired entries
        for scientificName := range t.statusCache </span><span class="cov0" title="0">{
                if currentTime.Sub(t.statusCache[scientificName].timestamp) &gt;= t.cacheTTL </span><span class="cov0" title="0">{
                        delete(t.statusCache, scientificName)
                }</span>
        }

        // Second pass: if still over limit, remove oldest entries (LRU)
        <span class="cov0" title="0">if len(t.statusCache) &gt; maxStatusCacheSize </span><span class="cov0" title="0">{
                // Create a slice of entries for sorting
                type cacheEntry struct {
                        name      string
                        timestamp time.Time
                }
                entries := make([]cacheEntry, 0, len(t.statusCache))
                for name := range t.statusCache </span><span class="cov0" title="0">{
                        entries = append(entries, cacheEntry{name: name, timestamp: t.statusCache[name].timestamp})
                }</span>

                // Sort by timestamp (oldest first)
                // Note: We could optimize this with a proper LRU implementation if needed
                <span class="cov0" title="0">for i := 0; i &lt; len(entries)-1; i++ </span><span class="cov0" title="0">{
                        for j := i + 1; j &lt; len(entries); j++ </span><span class="cov0" title="0">{
                                if entries[i].timestamp.After(entries[j].timestamp) </span><span class="cov0" title="0">{
                                        entries[i], entries[j] = entries[j], entries[i]
                                }</span>
                        }
                }

                // Remove oldest entries until we're under the limit
                <span class="cov0" title="0">entriesToRemove := len(t.statusCache) - maxStatusCacheSize
                for i := 0; i &lt; entriesToRemove &amp;&amp; i &lt; len(entries); i++ </span><span class="cov0" title="0">{
                        delete(t.statusCache, entries[i].name)
                }</span>

                <span class="cov0" title="0">logger.Debug("Cache cleanup completed",
                        "removed_count", entriesToRemove,
                        "remaining_count", len(t.statusCache))</span>
        }
}

// GetBatchSpeciesStatus returns the tracking status for multiple species in a single operation
// This method significantly reduces mutex contention and redundant computations compared to
// calling GetSpeciesStatus individually for each species. It performs expensive operations
// like checkAndResetPeriods() and getCurrentSeason() only once for the entire batch.
func (t *NewSpeciesTracker) GetBatchSpeciesStatus(scientificNames []string, currentTime time.Time) map[string]SpeciesStatus <span class="cov0" title="0">{
        if len(scientificNames) == 0 </span><span class="cov0" title="0">{
                return make(map[string]SpeciesStatus)
        }</span>

        <span class="cov0" title="0">t.mu.Lock()
        defer t.mu.Unlock()

        // Perform expensive operations only once for the entire batch
        t.checkAndResetPeriods(currentTime)
        currentSeason := t.getCurrentSeason(currentTime)

        // Pre-allocate result map with exact capacity
        results := make(map[string]SpeciesStatus, len(scientificNames))

        // Process each species using the cached season information
        for _, scientificName := range scientificNames </span><span class="cov0" title="0">{
                status := t.buildSpeciesStatusLocked(scientificName, currentTime, currentSeason)
                results[scientificName] = status
        }</span>

        <span class="cov0" title="0">return results</span>
}

// buildSpeciesStatusLocked builds a species status without acquiring locks or performing
// expensive period checks. This is used internally by GetBatchSpeciesStatus.
// Assumes the caller already holds the mutex lock.
func (t *NewSpeciesTracker) buildSpeciesStatusLocked(scientificName string, currentTime time.Time, currentSeason string) SpeciesStatus <span class="cov0" title="0">{
        // Lifetime tracking
        firstSeen, exists := t.speciesFirstSeen[scientificName]

        // Yearly tracking
        var firstThisYear *time.Time
        if t.yearlyEnabled </span><span class="cov0" title="0">{
                if yearTime, yearExists := t.speciesThisYear[scientificName]; yearExists </span><span class="cov0" title="0">{
                        // Create a copy to avoid pointer to loop variable issue
                        timeCopy := yearTime
                        firstThisYear = &amp;timeCopy
                }</span>
        }

        // Seasonal tracking - check current season only (matches original behavior)
        <span class="cov0" title="0">var firstThisSeason *time.Time
        if t.seasonalEnabled &amp;&amp; t.speciesBySeason[currentSeason] != nil </span><span class="cov0" title="0">{
                if seasonTime, seasonExists := t.speciesBySeason[currentSeason][scientificName]; seasonExists </span><span class="cov0" title="0">{
                        // Create a copy to avoid pointer to loop variable issue
                        timeCopy := seasonTime
                        firstThisSeason = &amp;timeCopy
                }</span>
        }

        // Build status struct (cannot reuse statusBuffer in batch operations)
        <span class="cov0" title="0">status := SpeciesStatus{
                FirstSeenTime:   firstSeen,
                IsNew:           false,
                DaysSinceFirst:  -1,
                LastUpdatedTime: currentTime,
                FirstThisYear:   firstThisYear,
                FirstThisSeason: firstThisSeason,
                CurrentSeason:   currentSeason,
                IsNewThisYear:   false,
                IsNewThisSeason: false,
                DaysThisYear:    -1,
                DaysThisSeason:  -1,
        }

        // Calculate lifetime status
        if exists </span><span class="cov0" title="0">{
                daysSince := int(currentTime.Sub(firstSeen).Hours() / hoursPerDay)
                status.DaysSinceFirst = daysSince
                status.IsNew = daysSince &lt;= t.windowDays
        }</span> else<span class="cov0" title="0"> {
                // Species not seen before
                status.IsNew = true
                status.DaysSinceFirst = 0
        }</span>

        // Calculate yearly status
        <span class="cov0" title="0">if t.yearlyEnabled </span><span class="cov0" title="0">{
                if firstThisYear != nil </span><span class="cov0" title="0">{
                        daysThisYear := int(currentTime.Sub(*firstThisYear).Hours() / hoursPerDay)
                        status.DaysThisYear = daysThisYear
                        status.IsNewThisYear = daysThisYear &lt;= t.yearlyWindowDays
                }</span> else<span class="cov0" title="0"> {
                        // First time this year
                        status.IsNewThisYear = true
                        status.DaysThisYear = 0
                }</span>
        }

        // Calculate seasonal status
        <span class="cov0" title="0">if t.seasonalEnabled </span><span class="cov0" title="0">{
                if firstThisSeason != nil </span><span class="cov0" title="0">{
                        daysThisSeason := int(currentTime.Sub(*firstThisSeason).Hours() / hoursPerDay)
                        status.DaysThisSeason = daysThisSeason
                        status.IsNewThisSeason = daysThisSeason &lt;= t.seasonalWindowDays
                }</span> else<span class="cov0" title="0"> {
                        // First time this season
                        status.IsNewThisSeason = true
                        status.DaysThisSeason = 0
                }</span>
        }

        <span class="cov0" title="0">return status</span>
}

// UpdateSpecies updates the first seen time for a species if necessary
// Returns true if this is a new species detection
func (t *NewSpeciesTracker) UpdateSpecies(scientificName string, detectionTime time.Time) bool <span class="cov8" title="1">{
        t.mu.Lock()
        defer t.mu.Unlock()

        // Check and reset periods if needed
        t.checkAndResetPeriods(detectionTime)

        // Lifetime tracking
        firstSeen, exists := t.speciesFirstSeen[scientificName]
        isNewSpecies := false

        if !exists </span><span class="cov8" title="1">{
                // New species detected
                t.speciesFirstSeen[scientificName] = detectionTime
                isNewSpecies = true
                logger.Debug("New lifetime species detected",
                        "species", scientificName,
                        "detection_time", detectionTime.Format("2006-01-02 15:04:05"))
        }</span> else<span class="cov8" title="1"> if detectionTime.Before(firstSeen) </span><span class="cov0" title="0">{
                // Update if this detection is earlier than recorded
                t.speciesFirstSeen[scientificName] = detectionTime
                logger.Debug("Updated lifetime first seen to earlier date",
                        "species", scientificName,
                        "old_date", firstSeen.Format("2006-01-02"),
                        "new_date", detectionTime.Format("2006-01-02"))
        }</span>

        // Update yearly tracking
        <span class="cov8" title="1">if t.yearlyEnabled </span><span class="cov8" title="1">{
                if t.isWithinCurrentYear(detectionTime) </span><span class="cov8" title="1">{
                        if _, yearExists := t.speciesThisYear[scientificName]; !yearExists </span><span class="cov8" title="1">{
                                t.speciesThisYear[scientificName] = detectionTime
                                logger.Debug("New species for this year",
                                        "species", scientificName,
                                        "detection_time", detectionTime.Format("2006-01-02 15:04:05"),
                                        "current_year", t.currentYear)
                        }</span> else<span class="cov0" title="0"> {
                                // Update if this detection is earlier than the recorded one
                                existingTime := t.speciesThisYear[scientificName]
                                if detectionTime.Before(existingTime) </span><span class="cov0" title="0">{
                                        t.speciesThisYear[scientificName] = detectionTime
                                        logger.Debug("Updated yearly first seen to earlier date",
                                                "species", scientificName,
                                                "old_date", existingTime.Format("2006-01-02"),
                                                "new_date", detectionTime.Format("2006-01-02"),
                                                "current_year", t.currentYear)
                                }</span>
                        }
                } else<span class="cov0" title="0"> {
                        logger.Debug("Detection not within current year - skipping yearly update",
                                "species", scientificName,
                                "detection_time", detectionTime.Format("2006-01-02"),
                                "current_year", t.currentYear)
                }</span>
        }

        // Update seasonal tracking
        <span class="cov8" title="1">if t.seasonalEnabled </span><span class="cov8" title="1">{
                currentSeason := t.getCurrentSeason(detectionTime)
                if t.speciesBySeason[currentSeason] == nil </span><span class="cov0" title="0">{
                        t.speciesBySeason[currentSeason] = make(map[string]time.Time)
                        logger.Debug("Initialized new season map",
                                "season", currentSeason)
                }</span>
                <span class="cov8" title="1">if _, seasonExists := t.speciesBySeason[currentSeason][scientificName]; !seasonExists </span><span class="cov8" title="1">{
                        t.speciesBySeason[currentSeason][scientificName] = detectionTime
                        logger.Debug("New species for this season",
                                "species", scientificName,
                                "season", currentSeason,
                                "detection_time", detectionTime.Format("2006-01-02 15:04:05"))
                }</span>
        }

        // Invalidate cache entry for this species to ensure fresh status calculations
        <span class="cov8" title="1">delete(t.statusCache, scientificName)

        return isNewSpecies</span>
}

// IsNewSpecies checks if a species is considered "new" within the configured window
func (t *NewSpeciesTracker) IsNewSpecies(scientificName string) bool <span class="cov0" title="0">{
        t.mu.RLock()
        firstSeen, exists := t.speciesFirstSeen[scientificName]
        t.mu.RUnlock()

        if !exists </span><span class="cov0" title="0">{
                return true // Never seen before
        }</span>

        <span class="cov0" title="0">daysSince := int(time.Since(firstSeen).Hours() / hoursPerDay)
        return daysSince &lt;= t.windowDays</span>
}

// SyncIfNeeded checks if a database sync is needed and performs it
// This helps keep the tracker updated with any database changes
func (t *NewSpeciesTracker) SyncIfNeeded() error <span class="cov0" title="0">{
        t.mu.RLock()
        elapsed := time.Since(t.lastSyncTime)
        interval := t.syncIntervalMins
        t.mu.RUnlock()

        // Compare durations directly; min interval is in minutes
        if elapsed &lt; time.Duration(interval)*time.Minute </span><span class="cov0" title="0">{
                return nil // No sync needed yet
        }</span>

        // Store count of existing data before sync
        <span class="cov0" title="0">t.mu.RLock()
        existingLifetimeCount := len(t.speciesFirstSeen)
        existingYearlyCount := len(t.speciesThisYear)
        existingSeasonalCount := 0
        for _, seasonMap := range t.speciesBySeason </span><span class="cov0" title="0">{
                existingSeasonalCount += len(seasonMap)
        }</span>
        <span class="cov0" title="0">t.mu.RUnlock()

        // Log sync attempt
        logger.Debug("Starting database sync",
                "existing_lifetime_species", existingLifetimeCount,
                "existing_yearly_species", existingYearlyCount,
                "existing_seasonal_species", existingSeasonalCount)

        // Perform database sync
        if err := t.InitFromDatabase(); err != nil </span><span class="cov0" title="0">{
                logger.Error("Database sync failed, preserving existing data",
                        "error", err,
                        "existing_species", existingLifetimeCount)
                // Don't propagate error if we have existing data - continue with cached data
                if existingLifetimeCount &gt; 0 </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        // Check if sync suspiciously cleared all data
        <span class="cov0" title="0">t.mu.RLock()
        newLifetimeCount := len(t.speciesFirstSeen)
        t.mu.RUnlock()

        if existingLifetimeCount &gt; 0 &amp;&amp; newLifetimeCount == 0 </span><span class="cov0" title="0">{
                logger.Warn("Database sync returned no data but had existing data - possible database issue",
                        "previous_count", existingLifetimeCount,
                        "new_count", newLifetimeCount)
        }</span>

        // Also perform periodic cleanup of old records (both species and notification records)
        <span class="cov0" title="0">pruned := t.PruneOldEntries()
        if pruned &gt; 0 </span><span class="cov0" title="0">{
                logger.Debug("Pruned old entries during sync",
                        "count", pruned)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetWindowDays returns the configured window for new species
func (t *NewSpeciesTracker) GetWindowDays() int <span class="cov8" title="1">{
        return t.windowDays
}</span>

// GetSpeciesCount returns the number of tracked species
func (t *NewSpeciesTracker) GetSpeciesCount() int <span class="cov8" title="1">{
        t.mu.RLock()
        defer t.mu.RUnlock()
        return len(t.speciesFirstSeen)
}</span>

// PruneOldEntries removes species entries older than 2x their respective window periods
// This prevents unbounded memory growth over time using period-specific cutoff times
func (t *NewSpeciesTracker) PruneOldEntries() int <span class="cov8" title="1">{
        t.mu.Lock()
        defer t.mu.Unlock()

        now := time.Now()
        pruned := 0

        // Calculate separate cutoff times for each tracking period
        lifetimeCutoff := now.AddDate(0, 0, -t.windowDays*2)

        // Prune lifetime tracking map
        for scientificName, firstSeen := range t.speciesFirstSeen </span><span class="cov8" title="1">{
                if firstSeen.Before(lifetimeCutoff) </span><span class="cov8" title="1">{
                        delete(t.speciesFirstSeen, scientificName)
                        pruned++
                }</span>
        }

        // Prune yearly tracking map if enabled
        <span class="cov8" title="1">if t.yearlyEnabled </span><span class="cov0" title="0">{
                yearlyCutoff := now.AddDate(0, 0, -t.yearlyWindowDays*2)
                for scientificName, firstSeen := range t.speciesThisYear </span><span class="cov0" title="0">{
                        if firstSeen.Before(yearlyCutoff) </span><span class="cov0" title="0">{
                                delete(t.speciesThisYear, scientificName)
                                pruned++
                        }</span>
                }
        }

        // Prune seasonal tracking maps if enabled
        <span class="cov8" title="1">if t.seasonalEnabled </span><span class="cov0" title="0">{
                seasonalCutoff := now.AddDate(0, 0, -t.seasonalWindowDays*2)
                for season, speciesMap := range t.speciesBySeason </span><span class="cov0" title="0">{
                        for scientificName, firstSeen := range speciesMap </span><span class="cov0" title="0">{
                                if firstSeen.Before(seasonalCutoff) </span><span class="cov0" title="0">{
                                        delete(speciesMap, scientificName)
                                        pruned++
                                }</span>
                        }
                        // Remove empty seasonal maps to prevent memory leaks
                        <span class="cov0" title="0">if len(speciesMap) == 0 </span><span class="cov0" title="0">{
                                delete(t.speciesBySeason, season)
                        }</span>
                }
        }

        // Also cleanup old notification records (only if suppression is enabled)
        <span class="cov8" title="1">if t.notificationSuppressionWindow &gt; 0 </span><span class="cov0" title="0">{
                cleaned := t.cleanupOldNotificationRecordsLocked(now)
                pruned += cleaned
        }</span>

        <span class="cov8" title="1">return pruned</span>
}

// cleanupOldNotificationRecordsLocked is an internal version that assumes lock is already held
func (t *NewSpeciesTracker) cleanupOldNotificationRecordsLocked(currentTime time.Time) int <span class="cov0" title="0">{
        if t.notificationLastSent == nil || t.notificationSuppressionWindow &lt;= 0 </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov0" title="0">cleaned := 0
        // Compute cutoff = currentTime - (2 * suppressionWindow) to remove records older than 2x retention
        cutoffTime := currentTime.Add(-2 * t.notificationSuppressionWindow)

        for species, sentTime := range t.notificationLastSent </span><span class="cov0" title="0">{
                if sentTime.Before(cutoffTime) </span><span class="cov0" title="0">{
                        delete(t.notificationLastSent, species)
                        cleaned++
                }</span>
        }

        <span class="cov0" title="0">return cleaned</span>
}

// CheckAndUpdateSpecies atomically checks if a species is new and updates the tracker
// This prevents race conditions where multiple concurrent detections of the same species
// could all be considered "new" before any of them update the tracker.
// Returns (isNew, daysSinceFirstSeen)
func (t *NewSpeciesTracker) CheckAndUpdateSpecies(scientificName string, detectionTime time.Time) (isNew bool, daysSinceFirstSeen int) <span class="cov0" title="0">{
        t.mu.Lock()
        defer t.mu.Unlock()

        // Check and reset periods if needed
        t.checkAndResetPeriods(detectionTime)

        // Check current status before any updates
        firstSeen, exists := t.speciesFirstSeen[scientificName]

        if !exists </span><span class="cov0" title="0">{
                // Species not seen before - definitely new
                isNew = true
                daysSinceFirstSeen = 0
                // Record this as the first detection
                t.speciesFirstSeen[scientificName] = detectionTime
        }</span> else<span class="cov0" title="0"> {
                // Calculate days since first seen
                daysSince := int(detectionTime.Sub(firstSeen).Hours() / hoursPerDay)
                daysSinceFirstSeen = daysSince
                isNew = daysSince &lt;= t.windowDays

                // Update if this detection is earlier than recorded
                if detectionTime.Before(firstSeen) </span><span class="cov0" title="0">{
                        t.speciesFirstSeen[scientificName] = detectionTime
                }</span>
        }

        // Update yearly tracking
        <span class="cov0" title="0">if t.yearlyEnabled </span><span class="cov0" title="0">{
                if t.isWithinCurrentYear(detectionTime) </span><span class="cov0" title="0">{
                        if _, yearExists := t.speciesThisYear[scientificName]; !yearExists </span><span class="cov0" title="0">{
                                t.speciesThisYear[scientificName] = detectionTime
                        }</span>
                }
        }

        // Update seasonal tracking
        <span class="cov0" title="0">if t.seasonalEnabled </span><span class="cov0" title="0">{
                currentSeason := t.getCurrentSeason(detectionTime)
                if t.speciesBySeason[currentSeason] == nil </span><span class="cov0" title="0">{
                        t.speciesBySeason[currentSeason] = make(map[string]time.Time)
                }</span>
                <span class="cov0" title="0">if _, seasonExists := t.speciesBySeason[currentSeason][scientificName]; !seasonExists </span><span class="cov0" title="0">{
                        t.speciesBySeason[currentSeason][scientificName] = detectionTime
                }</span>
        }

        <span class="cov0" title="0">return</span>
}

// IsSeasonMapInitialized checks if the season map is properly initialized for the given season.
// This method provides safe access to internal state for testing purposes.
func (t *NewSpeciesTracker) IsSeasonMapInitialized(season string) bool <span class="cov0" title="0">{
        t.mu.RLock()
        defer t.mu.RUnlock()

        if !t.seasonalEnabled </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return t.speciesBySeason != nil &amp;&amp; t.speciesBySeason[season] != nil</span>
}

// GetSeasonMapCount returns the number of species tracked for the given season.
// This method provides safe access to internal state for testing purposes.
func (t *NewSpeciesTracker) GetSeasonMapCount(season string) int <span class="cov0" title="0">{
        t.mu.RLock()
        defer t.mu.RUnlock()

        if !t.seasonalEnabled || t.speciesBySeason == nil || t.speciesBySeason[season] == nil </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov0" title="0">return len(t.speciesBySeason[season])</span>
}

// ExpireCacheForTesting forces cache expiration for the given species for testing purposes.
// This method should only be used in tests to simulate cache expiration without
// manipulating internal state directly.
func (t *NewSpeciesTracker) ExpireCacheForTesting(scientificName string) <span class="cov0" title="0">{
        t.mu.Lock()
        defer t.mu.Unlock()

        if cached, exists := t.statusCache[scientificName]; exists </span><span class="cov0" title="0">{
                // Set timestamp to expired (1 hour ago)
                cached.timestamp = time.Now().Add(defaultCacheExpiredAge)
                t.statusCache[scientificName] = cached
        }</span>
}

// ClearCacheForTesting clears the entire status cache for testing purposes.
// This method should only be used in tests.
func (t *NewSpeciesTracker) ClearCacheForTesting() <span class="cov0" title="0">{
        t.mu.Lock()
        defer t.mu.Unlock()

        t.statusCache = make(map[string]cachedSpeciesStatus)
}</span>

// ShouldSuppressNotification checks if a notification for this species should be suppressed
// based on when the last notification was sent for this species.
// Returns true if notification should be suppressed, false if it should be sent.
func (t *NewSpeciesTracker) ShouldSuppressNotification(scientificName string, currentTime time.Time) bool <span class="cov0" title="0">{
        t.mu.RLock()
        lastSent, exists := t.notificationLastSent[scientificName]
        window := t.notificationSuppressionWindow
        t.mu.RUnlock()

        if !exists </span><span class="cov0" title="0">{
                return false // Never sent, don't suppress
        }</span>
        <span class="cov0" title="0">if window &lt;= 0 </span><span class="cov0" title="0">{
                return false // Suppression disabled
        }</span>

        <span class="cov0" title="0">suppressUntil := lastSent.Add(window)
        shouldSuppress := currentTime.Before(suppressUntil)

        if shouldSuppress </span><span class="cov0" title="0">{
                logger.Debug("Suppressing duplicate notification",
                        "species", scientificName,
                        "suppress_until", suppressUntil,
                        "suppression_window", window)
        }</span>
        <span class="cov0" title="0">return shouldSuppress</span>
}

// RecordNotificationSent records that a notification was sent for a species.
// This is used to prevent duplicate notifications within the suppression window.
func (t *NewSpeciesTracker) RecordNotificationSent(scientificName string, sentTime time.Time) <span class="cov0" title="0">{
        // Early return when suppression is disabled to avoid unnecessary operations
        if t.notificationSuppressionWindow &lt;= 0 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">t.mu.Lock()
        // Initialize map if needed
        if t.notificationLastSent == nil </span><span class="cov0" title="0">{
                t.notificationLastSent = make(map[string]time.Time, initialSpeciesCapacity)
        }</span>

        // Record the notification time
        <span class="cov0" title="0">t.notificationLastSent[scientificName] = sentTime
        t.mu.Unlock()

        // Log outside the critical section to reduce lock contention
        logger.Debug("Recorded notification sent",
                "species", scientificName,
                "sent_time", sentTime.Format("2006-01-02 15:04:05"))</span>
}

// CleanupOldNotificationRecords removes notification records older than 2x the suppression window
// to prevent unbounded memory growth.
func (t *NewSpeciesTracker) CleanupOldNotificationRecords(currentTime time.Time) int <span class="cov0" title="0">{
        // Early return if suppression is disabled (0 window)
        if t.notificationSuppressionWindow &lt;= 0 </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov0" title="0">t.mu.Lock()
        cleaned := t.cleanupOldNotificationRecordsLocked(currentTime)
        t.mu.Unlock()

        if cleaned &gt; 0 </span><span class="cov0" title="0">{
                cutoffTime := currentTime.Add(-2 * t.notificationSuppressionWindow)
                logger.Debug("Cleaned up old notification records",
                        "removed_count", cleaned,
                        "cutoff_time", cutoffTime.Format("2006-01-02 15:04:05"))
        }</span>

        <span class="cov0" title="0">return cleaned</span>
}

// Close releases resources associated with the species tracker, including the logger.
// This should be called during application shutdown or when the tracker is no longer needed.
func (t *NewSpeciesTracker) Close() error <span class="cov0" title="0">{
        // Close the shared logger used by all tracker instances
        // Note: This is a package-level resource shared across all tracker instances
        if err := Close(); err != nil </span><span class="cov0" title="0">{
                return errors.New(err).
                        Component("new-species-tracker").
                        Category(errors.CategoryResource).
                        Context("operation", "close_logger").
                        Build()
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">// processor.go
package processor

import (
        "context"
        "fmt"
        "log"
        "math"
        "path/filepath"
        "strings"
        "sync"
        "sync/atomic"
        "time"

        "github.com/tphakala/birdnet-go/internal/analysis/jobqueue"
        "github.com/tphakala/birdnet-go/internal/birdnet"
        "github.com/tphakala/birdnet-go/internal/birdweather"
        "github.com/tphakala/birdnet-go/internal/conf"
        "github.com/tphakala/birdnet-go/internal/datastore"
        "github.com/tphakala/birdnet-go/internal/imageprovider"
        "github.com/tphakala/birdnet-go/internal/mqtt"
        "github.com/tphakala/birdnet-go/internal/myaudio"
        "github.com/tphakala/birdnet-go/internal/observability"
        "github.com/tphakala/birdnet-go/internal/privacy"
)

// Species identification constants for filtering
const (
        speciesDog   = "dog"
        speciesHuman = "human"
)

// Processor represents the main processing unit for audio analysis.
type Processor struct {
        Settings            *conf.Settings
        Ds                  datastore.Interface
        Bn                  *birdnet.BirdNET
        BwClient            *birdweather.BwClient
        bwClientMutex       sync.RWMutex // Mutex to protect BwClient access
        MqttClient          mqtt.Client
        mqttMutex           sync.RWMutex // Mutex to protect MQTT client access
        BirdImageCache      *imageprovider.BirdImageCache
        EventTracker        *EventTracker
        eventTrackerMu      sync.RWMutex         // Mutex to protect EventTracker access
        NewSpeciesTracker   *NewSpeciesTracker   // Tracks new species detections
        speciesTrackerMu    sync.RWMutex         // Mutex to protect NewSpeciesTracker access
        lastSyncAttempt     time.Time            // Last time sync was attempted
        syncMutex           sync.Mutex           // Mutex to protect sync operations
        syncInProgress      atomic.Bool          // Flag to prevent overlapping syncs
        LastDogDetection    map[string]time.Time // keep track of dog barks per audio source
        LastHumanDetection  map[string]time.Time // keep track of human vocal per audio source
        Metrics             *observability.Metrics
        DynamicThresholds   map[string]*DynamicThreshold
        thresholdsMutex     sync.RWMutex // Mutex to protect access to DynamicThresholds
        pendingDetections   map[string]PendingDetection
        pendingMutex        sync.Mutex // Mutex to protect access to pendingDetections
        lastDogDetectionLog map[string]time.Time
        dogDetectionMutex   sync.Mutex
        detectionMutex      sync.RWMutex // Mutex to protect LastDogDetection and LastHumanDetection maps
        controlChan         chan string
        JobQueue            *jobqueue.JobQueue // Queue for managing job retries
        workerCancel        context.CancelFunc // Function to cancel worker goroutines
        // SSE related fields
        SSEBroadcaster      func(note *datastore.Note, birdImage *imageprovider.BirdImage) error // Function to broadcast detection via SSE
        sseBroadcasterMutex sync.RWMutex                                                         // Mutex to protect SSE broadcaster access

        // Backup system fields (optional)
        backupManager   interface{} // Use interface{} to avoid import cycle
        backupScheduler interface{} // Use interface{} to avoid import cycle
        backupMutex     sync.RWMutex

        // Log deduplication (extracted to separate type for SRP)
        logDedup *LogDeduplicator // Handles log deduplication logic
}

// DynamicThreshold represents the dynamic threshold configuration for a species.
type DynamicThreshold struct {
        Level         int
        CurrentValue  float64
        Timer         time.Time
        HighConfCount int
        ValidHours    int
}

type Detections struct {
        pcmData3s []byte              // 3s PCM data containing the detection
        Note      datastore.Note      // Note containing highest match
        Results   []datastore.Results // Full BirdNET prediction results
}

// PendingDetection struct represents a single detection held in memory,
// including its last updated timestamp and a deadline for flushing it to the worker queue.
type PendingDetection struct {
        Detection     Detections // The detection data
        Confidence    float64    // Confidence level of the detection
        Source        string     // Audio source of the detection, RTSP URL or audio card name
        FirstDetected time.Time  // Time the detection was first detected
        LastUpdated   time.Time  // Last time this detection was updated
        FlushDeadline time.Time  // Deadline by which the detection must be processed
        Count         int        // Number of times this detection has been updated
}

// mutex is used to synchronize access to the PendingDetections map,
// ensuring thread safety when the map is accessed or modified by concurrent goroutines.
var mutex sync.Mutex

// func New(settings *conf.Settings, ds datastore.Interface, bn *birdnet.BirdNET, audioBuffers map[string]*myaudio.AudioBuffer, metrics *observability.Metrics) *Processor {
func New(settings *conf.Settings, ds datastore.Interface, bn *birdnet.BirdNET, metrics *observability.Metrics, birdImageCache *imageprovider.BirdImageCache) *Processor <span class="cov0" title="0">{
        p := &amp;Processor{
                Settings:       settings,
                Ds:             ds,
                Bn:             bn,
                BirdImageCache: birdImageCache,
                EventTracker: NewEventTrackerWithConfig(
                        time.Duration(settings.Realtime.Interval)*time.Second,
                        settings.Realtime.Species.Config,
                ),
                Metrics:             metrics,
                LastDogDetection:    make(map[string]time.Time),
                LastHumanDetection:  make(map[string]time.Time),
                DynamicThresholds:   make(map[string]*DynamicThreshold),
                pendingDetections:   make(map[string]PendingDetection),
                lastDogDetectionLog: make(map[string]time.Time),
                controlChan:         make(chan string, 10),  // Buffered channel to prevent blocking
                JobQueue:            jobqueue.NewJobQueue(), // Initialize the job queue
        }

        // Initialize log deduplicator with configuration from settings
        // This addresses separation of concerns by extracting deduplication logic
        healthCheckInterval := 60 * time.Second // default
        
        // Validate and use settings if available
        if settings.Realtime.LogDeduplication.HealthCheckIntervalSeconds &gt; 0 </span><span class="cov0" title="0">{
                // Cap at reasonable maximum (1 hour) to prevent misconfiguration
                if settings.Realtime.LogDeduplication.HealthCheckIntervalSeconds &gt; 3600 </span><span class="cov0" title="0">{
                        healthCheckInterval = time.Hour
                        GetLogger().Warn("Log deduplication health check interval capped at 1 hour",
                                "requested_seconds", settings.Realtime.LogDeduplication.HealthCheckIntervalSeconds,
                                "capped_seconds", 3600,
                                "operation", "config_validation")
                }</span> else<span class="cov0" title="0"> {
                        healthCheckInterval = time.Duration(settings.Realtime.LogDeduplication.HealthCheckIntervalSeconds) * time.Second
                }</span>
        }
        <span class="cov0" title="0">enabled := settings.Realtime.LogDeduplication.Enabled
        
        logConfig := DeduplicationConfig{
                HealthCheckInterval: healthCheckInterval,
                Enabled:             enabled,
        }
        p.logDedup = NewLogDeduplicator(logConfig)

        // Initialize new species tracker if enabled
        if settings.Realtime.SpeciesTracking.Enabled </span><span class="cov0" title="0">{
                // Validate species tracking configuration
                if err := settings.Realtime.SpeciesTracking.Validate(); err != nil </span><span class="cov0" title="0">{
                        // Add structured logging
                        GetLogger().Error("Invalid species tracking configuration",
                                "error", err,
                                "operation", "species_tracking_validation")
                        log.Printf("Invalid species tracking configuration: %v", err)
                        // Continue with defaults or disable tracking
                        settings.Realtime.SpeciesTracking.Enabled = false
                }</span> else<span class="cov0" title="0"> {
                        // Adjust seasonal tracking for hemisphere based on BirdNET latitude
                        hemisphereAwareTracking := settings.Realtime.SpeciesTracking
                        if hemisphereAwareTracking.SeasonalTracking.Enabled </span><span class="cov0" title="0">{
                                hemisphereAwareTracking.SeasonalTracking = conf.GetSeasonalTrackingWithHemisphere(
                                        hemisphereAwareTracking.SeasonalTracking,
                                        settings.BirdNET.Latitude,
                                )
                        }</span>
                        
                        <span class="cov0" title="0">p.NewSpeciesTracker = NewSpeciesTrackerFromSettings(ds, &amp;hemisphereAwareTracking)

                        // Initialize species tracker from database
                        if err := p.NewSpeciesTracker.InitFromDatabase(); err != nil </span><span class="cov0" title="0">{
                                // Add structured logging
                                GetLogger().Error("Failed to initialize species tracker from database",
                                        "error", err,
                                        "operation", "species_tracker_init")
                                log.Printf("Failed to initialize species tracker from database: %v", err)
                                // Continue anyway - tracker will work for new detections
                        }</span>

                        <span class="cov0" title="0">hemisphere := conf.DetectHemisphere(settings.BirdNET.Latitude)
                        // Add structured logging
                        GetLogger().Info("Species tracking enabled",
                                "window_days", settings.Realtime.SpeciesTracking.NewSpeciesWindowDays,
                                "sync_interval_minutes", settings.Realtime.SpeciesTracking.SyncIntervalMinutes,
                                "hemisphere", hemisphere,
                                "latitude", settings.BirdNET.Latitude,
                                "operation", "species_tracking_config")
                        log.Printf("Species tracking enabled: window=%d days, sync=%d minutes, hemisphere=%s (lat=%.2f)",
                                settings.Realtime.SpeciesTracking.NewSpeciesWindowDays,
                                settings.Realtime.SpeciesTracking.SyncIntervalMinutes,
                                hemisphere,
                                settings.BirdNET.Latitude)</span>
                }
        }

        // Start the detection processor
        <span class="cov0" title="0">p.startDetectionProcessor()

        // Start the worker pool for action processing
        p.startWorkerPool()

        // Start the held detection flusher
        p.pendingDetectionsFlusher()

        // Initialize BirdWeather client if enabled in settings
        if settings.Realtime.Birdweather.Enabled </span><span class="cov0" title="0">{
                var err error
                bwClient, err := birdweather.New(settings)
                if err != nil </span><span class="cov0" title="0">{
                        // Add structured logging
                        GetLogger().Error("Failed to create BirdWeather client",
                                "error", err,
                                "operation", "birdweather_client_init",
                                "integration", "birdweather")
                        log.Printf("failed to create Birdweather client: %s", err)
                }</span> else<span class="cov0" title="0"> {
                        p.SetBwClient(bwClient) // Use setter for thread safety
                }</span>
        }

        // Initialize MQTT client if enabled in settings
        <span class="cov0" title="0">p.initializeMQTT(settings)

        // Start the job queue
        p.JobQueue.Start()

        return p</span>
}

// Start goroutine to process detections from the queue
func (p *Processor) startDetectionProcessor() <span class="cov0" title="0">{
        // Add structured logging for detection processor startup
        GetLogger().Info("Starting detection processor",
                "operation", "detection_processor_startup")
        go func() </span><span class="cov0" title="0">{
                // ResultsQueue is fed by myaudio.ProcessData()
                for item := range birdnet.ResultsQueue </span><span class="cov0" title="0">{
                        // Pass by value since we own the data (see queue.go ownership comment)
                        p.processDetections(item)
                }</span>
                // Add structured logging when processor stops
                <span class="cov0" title="0">GetLogger().Info("Detection processor stopped",
                        "operation", "detection_processor_shutdown")</span>
        }()
}

// processDetections examines each detection from the queue, updating held detections
// with new or higher-confidence instances and setting an appropriate flush deadline.
//
//nolint:gocritic // hugeParam: Pass by value is intentional - avoids pointer dereferencing in hot path
func (p *Processor) processDetections(item birdnet.Results) <span class="cov0" title="0">{
        // Add structured logging for detection pipeline entry
        GetLogger().Debug("Processing detections from queue",
                "source", item.Source.DisplayName,
                "start_time", item.StartTime,
                "results_count", len(item.Results),
                "elapsed_time_ms", item.ElapsedTime.Milliseconds(),
                "operation", "process_detections_entry")

        // Delay before a detection is considered final and is flushed.
        // TODO: make this configurable
        const delay = 15 * time.Second

        // processResults() returns a slice of detections, we iterate through each and process them
        // detections are put into pendingDetections map where they are held until flush deadline is reached
        // once deadline is reached detections are delivered to workers for actions (save to db etc) processing
        detectionResults := p.processResults(item)
        
        // Log processing results with deduplication to prevent spam
        p.logDetectionResults(item.Source.ID, len(item.Results), len(detectionResults))

        for i := 0; i &lt; len(detectionResults); i++ </span><span class="cov0" title="0">{
                detection := detectionResults[i]
                commonName := strings.ToLower(detection.Note.CommonName)
                confidence := detection.Note.Confidence

                // Lock the mutex to ensure thread-safe access to shared resources
                p.pendingMutex.Lock()

                if existing, exists := p.pendingDetections[commonName]; exists </span><span class="cov0" title="0">{
                        // Update the existing detection if it's already in pendingDetections map
                        oldConfidence := existing.Confidence
                        if confidence &gt; existing.Confidence </span><span class="cov0" title="0">{
                                existing.Detection = detection
                                existing.Confidence = confidence
                                existing.Source = item.Source.ID
                                existing.LastUpdated = time.Now()
                                // Add structured logging for confidence update
                                GetLogger().Debug("Updated pending detection with higher confidence",
                                        "species", commonName,
                                        "old_confidence", oldConfidence,
                                        "new_confidence", confidence,
                                        "count", existing.Count+1,
                                        "operation", "update_pending_detection")
                        }</span>
                        <span class="cov0" title="0">existing.Count++
                        p.pendingDetections[commonName] = existing</span>
                } else<span class="cov0" title="0"> {
                        // Create a new pending detection if it doesn't exist
                        // Add structured logging for new pending detection
                        GetLogger().Info("Created new pending detection",
                                "species", commonName,
                                "confidence", confidence,
                                "source", item.Source.DisplayName,
                                "flush_deadline", item.StartTime.Add(delay),
                                "operation", "create_pending_detection")
                        p.pendingDetections[commonName] = PendingDetection{
                                Detection:     detection,
                                Confidence:    confidence,
                                Source:        item.Source.ID,
                                FirstDetected: item.StartTime,
                                FlushDeadline: item.StartTime.Add(delay),
                                Count:         1,
                        }
                }</span>

                // Update the dynamic threshold for this species if enabled
                <span class="cov0" title="0">p.updateDynamicThreshold(commonName, confidence)

                // Unlock the mutex to allow other goroutines to access shared resources
                p.pendingMutex.Unlock()</span>
        }
}

// processResults processes the results from the BirdNET prediction and returns a list of detections.
//
//nolint:gocritic // hugeParam: Pass by value is intentional - avoids pointer dereferencing in hot path
func (p *Processor) processResults(item birdnet.Results) []Detections <span class="cov0" title="0">{
        // Pre-allocate slice with capacity for all results
        detections := make([]Detections, 0, len(item.Results))

        // Collect processing time metric
        if p.Settings.Realtime.Telemetry.Enabled &amp;&amp; p.Metrics != nil &amp;&amp; p.Metrics.BirdNET != nil </span><span class="cov0" title="0">{
                p.Metrics.BirdNET.SetProcessTime(float64(item.ElapsedTime.Milliseconds()))
        }</span>

        // Sync species tracker if needed
        <span class="cov0" title="0">p.syncSpeciesTrackerIfNeeded()

        // Process each result in item.Results
        for _, result := range item.Results </span><span class="cov0" title="0">{
                // Parse and validate species information
                scientificName, commonName, speciesCode, speciesLowercase := p.parseAndValidateSpecies(result, item)
                // Skip if either scientific or common name is missing (partial/invalid parsing)
                if scientificName == "" || commonName == "" </span><span class="cov0" title="0">{
                        if p.Settings.Debug </span><span class="cov0" title="0">{
                                GetLogger().Debug("Skipping partially parsed species",
                                        "scientific_name", scientificName,
                                        "common_name", commonName,
                                        "species_code", speciesCode,
                                        "species_lowercase", speciesLowercase,
                                        "original_species", result.Species,
                                        "confidence", result.Confidence,
                                        "operation", "validate_species")
                        }</span>
                        <span class="cov0" title="0">continue</span> // Skip invalid or partially parsed species
                }

                // Handle dog and human detection, this sets LastDogDetection and LastHumanDetection which is
                // later used to discard detection if privacy filter or dog bark filters are enabled in settings.
                <span class="cov0" title="0">p.handleDogDetection(item, speciesLowercase, result)
                p.handleHumanDetection(item, speciesLowercase, result)

                // Determine confidence threshold and check filters
                baseThreshold := p.getBaseConfidenceThreshold(speciesLowercase)
                
                // Check if detection should be filtered
                shouldSkip, _ := p.shouldFilterDetection(result, commonName, speciesLowercase, baseThreshold, item.Source.ID)
                if shouldSkip </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Add species to dynamic thresholds if enabled and passed filters
                <span class="cov0" title="0">if p.Settings.Realtime.DynamicThreshold.Enabled </span><span class="cov0" title="0">{
                        p.addSpeciesToDynamicThresholds(speciesLowercase, baseThreshold)
                }</span>

                // Create the detection
                <span class="cov0" title="0">detection := p.createDetection(item, result, scientificName, commonName, speciesCode)
                detections = append(detections, detection)</span>
        }

        <span class="cov0" title="0">return detections</span>
}

// parseAndValidateSpecies parses species information and validates it
//
//nolint:gocritic // hugeParam: Pass by value is intentional - avoids pointer dereferencing in hot path
func (p *Processor) parseAndValidateSpecies(result datastore.Results, item birdnet.Results) (scientificName, commonName, speciesCode, speciesLowercase string) <span class="cov0" title="0">{
        // Use BirdNET's EnrichResultWithTaxonomy to get species information
        scientificName, commonName, speciesCode = p.Bn.EnrichResultWithTaxonomy(result.Species)

        // Skip processing if we couldn't parse the species properly (either name missing)
        if commonName == "" || scientificName == "" </span><span class="cov0" title="0">{
                if p.Settings.Debug </span><span class="cov0" title="0">{
                        GetLogger().Debug("Skipping species with invalid format",
                                "species", result.Species,
                                "confidence", result.Confidence,
                                "operation", "species_format_validation")
                        log.Printf("Skipping species with invalid format: %s", result.Species)
                }</span>
                <span class="cov0" title="0">return "", "", "", ""</span>
        }

        // Log placeholder taxonomy codes if using custom model
        <span class="cov0" title="0">if p.Settings.BirdNET.ModelPath != "" &amp;&amp; p.Settings.Debug &amp;&amp; speciesCode != "" </span><span class="cov0" title="0">{
                if len(speciesCode) == 8 &amp;&amp; (speciesCode[:2] == "XX" || (speciesCode[0] &gt;= 'A' &amp;&amp; speciesCode[0] &lt;= 'Z' &amp;&amp; speciesCode[1] &gt;= 'A' &amp;&amp; speciesCode[1] &lt;= 'Z')) </span><span class="cov0" title="0">{
                        GetLogger().Debug("Using placeholder taxonomy code",
                                "taxonomy_code", speciesCode,
                                "scientific_name", scientificName,
                                "common_name", commonName,
                                "operation", "taxonomy_code_assignment")
                        log.Printf("Using placeholder taxonomy code %s for species %s (%s)", speciesCode, scientificName, commonName)
                }</span>
        }

        // Convert species to lowercase for case-insensitive comparison
        <span class="cov0" title="0">speciesLowercase = strings.ToLower(commonName)
        if speciesLowercase == "" &amp;&amp; scientificName != "" </span><span class="cov0" title="0">{
                speciesLowercase = strings.ToLower(scientificName)
        }</span>

        <span class="cov0" title="0">return</span>
}

// shouldFilterDetection checks if a detection should be filtered out
func (p *Processor) shouldFilterDetection(result datastore.Results, commonName, speciesLowercase string, baseThreshold float32, source string) (shouldFilter bool, confidenceThreshold float32) <span class="cov0" title="0">{
        // Check human detection privacy filter
        if strings.Contains(strings.ToLower(commonName), speciesHuman) &amp;&amp; result.Confidence &gt; baseThreshold </span><span class="cov0" title="0">{
                return true, 0 // Filter out human detections for privacy
        }</span>

        // Determine confidence threshold
        <span class="cov0" title="0">if p.Settings.Realtime.DynamicThreshold.Enabled </span><span class="cov0" title="0">{
                confidenceThreshold = p.getAdjustedConfidenceThreshold(speciesLowercase, result, baseThreshold)
        }</span> else<span class="cov0" title="0"> {
                confidenceThreshold = baseThreshold
        }</span>

        // Check confidence threshold
        <span class="cov0" title="0">if result.Confidence &lt;= confidenceThreshold </span><span class="cov0" title="0">{
                if p.Settings.Debug </span><span class="cov0" title="0">{
                        GetLogger().Debug("Detection filtered out due to low confidence",
                                "species", result.Species,
                                "confidence", result.Confidence,
                                "threshold", confidenceThreshold,
                                "source", p.getDisplayNameForSource(source),
                                "operation", "confidence_filter")
                }</span>
                <span class="cov0" title="0">return true, confidenceThreshold</span>
        }

        // Check species inclusion filter
        <span class="cov0" title="0">if !p.Settings.IsSpeciesIncluded(result.Species) </span><span class="cov0" title="0">{
                if p.Settings.Debug </span><span class="cov0" title="0">{
                        GetLogger().Debug("Species not on included list",
                                "species", result.Species,
                                "confidence", result.Confidence,
                                "operation", "species_inclusion_filter")
                        log.Printf("Species not on included list: %s\n", result.Species)
                }</span>
                <span class="cov0" title="0">return true, confidenceThreshold</span>
        }

        <span class="cov0" title="0">return false, confidenceThreshold</span>
}

// createDetection creates a detection object with all necessary information
//
//nolint:gocritic // hugeParam: Pass by value is intentional - avoids pointer dereferencing in hot path
func (p *Processor) createDetection(item birdnet.Results, result datastore.Results, scientificName, commonName, speciesCode string) Detections <span class="cov0" title="0">{
        // Create file name for audio clip
        clipName := p.generateClipName(scientificName, result.Confidence)

        // Set begin and end time for note
        beginTime, endTime := item.StartTime, item.StartTime.Add(15*time.Second)

        // Create the note
        note := p.NewWithSpeciesInfo(
                beginTime, endTime,
                scientificName, commonName, speciesCode,
                float64(result.Confidence),
                item.Source.ID, clipName,
                item.ElapsedTime)

        // Update species tracker if enabled
        p.speciesTrackerMu.RLock()
        tracker := p.NewSpeciesTracker
        p.speciesTrackerMu.RUnlock()

        if tracker != nil </span><span class="cov0" title="0">{
                tracker.UpdateSpecies(scientificName, item.StartTime)
        }</span>

        <span class="cov0" title="0">return Detections{
                pcmData3s: item.PCMdata,
                Note:      note,
                Results:   item.Results,
        }</span>
}

// syncSpeciesTrackerIfNeeded syncs the species tracker if conditions are met
func (p *Processor) syncSpeciesTrackerIfNeeded() <span class="cov0" title="0">{
        p.speciesTrackerMu.RLock()
        tracker := p.NewSpeciesTracker
        p.speciesTrackerMu.RUnlock()

        if tracker != nil </span><span class="cov0" title="0">{
                // Rate limit sync operations to avoid excessive goroutines
                p.syncMutex.Lock()
                if time.Since(p.lastSyncAttempt) &gt;= time.Minute </span><span class="cov0" title="0">{
                        // Check if sync is already in progress
                        if !p.syncInProgress.Load() </span><span class="cov0" title="0">{
                                p.lastSyncAttempt = time.Now()
                                p.syncInProgress.Store(true) // Mark sync as in progress
                                go func() </span><span class="cov0" title="0">{
                                        defer p.syncInProgress.Store(false) // Always clear the flag when done
                                        if err := tracker.SyncIfNeeded(); err != nil </span><span class="cov0" title="0">{
                                                GetLogger().Error("Failed to sync species tracker",
                                                        "error", err,
                                                        "operation", "species_tracker_sync")
                                                log.Printf("Failed to sync species tracker: %v", err)
                                        }</span>
                                }()
                        }
                }
                <span class="cov0" title="0">p.syncMutex.Unlock()</span>
        }
}

// handleDogDetection handles the detection of dog barks and updates the last detection timestamp.
//
//nolint:gocritic // hugeParam: Pass by value is intentional - avoids pointer dereferencing in hot path
func (p *Processor) handleDogDetection(item birdnet.Results, speciesLowercase string, result datastore.Results) <span class="cov0" title="0">{
        if p.Settings.Realtime.DogBarkFilter.Enabled &amp;&amp; strings.Contains(speciesLowercase, speciesDog) &amp;&amp;
                result.Confidence &gt; p.Settings.Realtime.DogBarkFilter.Confidence </span><span class="cov0" title="0">{
                // Add structured logging
                GetLogger().Info("Dog detection filtered",
                        "confidence", result.Confidence,
                        "threshold", p.Settings.Realtime.DogBarkFilter.Confidence,
                        "source", item.Source.DisplayName,
                        "operation", "dog_bark_filter")
                log.Printf("Dog detected with confidence %.3f/%.3f from source %s", result.Confidence, p.Settings.Realtime.DogBarkFilter.Confidence, item.Source.DisplayName)
                p.detectionMutex.Lock()
                p.LastDogDetection[item.Source.ID] = item.StartTime
                p.detectionMutex.Unlock()
        }</span>
}

// handleHumanDetection handles the detection of human vocalizations and updates the last detection timestamp.
//
//nolint:gocritic // hugeParam: Pass by value is intentional - avoids pointer dereferencing in hot path
func (p *Processor) handleHumanDetection(item birdnet.Results, speciesLowercase string, result datastore.Results) <span class="cov0" title="0">{
        // only check this if privacy filter is enabled
        if p.Settings.Realtime.PrivacyFilter.Enabled &amp;&amp; strings.Contains(speciesLowercase, "human ") &amp;&amp;
                result.Confidence &gt; p.Settings.Realtime.PrivacyFilter.Confidence </span><span class="cov0" title="0">{
                // Add structured logging
                GetLogger().Info("Human detection filtered",
                        "confidence", result.Confidence,
                        "threshold", p.Settings.Realtime.PrivacyFilter.Confidence,
                        "source", item.Source.DisplayName,
                        "operation", "privacy_filter")
                log.Printf("Human detected with confidence %.3f/%.3f from source %s", result.Confidence, p.Settings.Realtime.PrivacyFilter.Confidence, item.Source.DisplayName)
                // put human detection timestamp into LastHumanDetection map. This is used to discard
                // bird detections if a human vocalization is detected after the first detection
                p.detectionMutex.Lock()
                p.LastHumanDetection[item.Source.ID] = item.StartTime
                p.detectionMutex.Unlock()
        }</span>
}

// getBaseConfidenceThreshold retrieves the confidence threshold for a species, using custom or global thresholds.
func (p *Processor) getBaseConfidenceThreshold(speciesLowercase string) float32 <span class="cov0" title="0">{
        // Check if species has a custom threshold in the new structure
        if config, exists := p.Settings.Realtime.Species.Config[speciesLowercase]; exists </span><span class="cov0" title="0">{
                if p.Settings.Debug </span><span class="cov0" title="0">{
                        // Add structured logging
                        GetLogger().Debug("Using custom confidence threshold",
                                "species", speciesLowercase,
                                "threshold", config.Threshold,
                                "operation", "custom_threshold_lookup")
                        log.Printf("\nUsing custom confidence threshold of %.2f for %s\n", config.Threshold, speciesLowercase)
                }</span>
                <span class="cov0" title="0">return float32(config.Threshold)</span>
        }

        // Fall back to global threshold
        <span class="cov0" title="0">return float32(p.Settings.BirdNET.Threshold)</span>
}

// generateClipName generates a clip name for the given scientific name and confidence.
func (p *Processor) generateClipName(scientificName string, confidence float32) string <span class="cov0" title="0">{
        // Replace whitespaces with underscores and convert to lowercase
        formattedName := strings.ToLower(strings.ReplaceAll(scientificName, " ", "_"))

        // Normalize the confidence value to a percentage and append 'p'
        normalizedConfidence := confidence * 100
        formattedConfidence := fmt.Sprintf("%.0fp", normalizedConfidence)

        // Get the current time
        currentTime := time.Now()

        // Format the timestamp in ISO 8601 format
        timestamp := currentTime.Format("20060102T150405Z")

        // Extract the year and month for directory structure
        year := currentTime.Format("2006")
        month := currentTime.Format("01")

        // Get the file extension from the export settings
        fileType := myaudio.GetFileExtension(p.Settings.Realtime.Audio.Export.Type)

        // Construct the clip name with the new pattern, including year and month subdirectories
        // Use filepath.ToSlash to convert the path to a forward slash for web URLs
        clipName := filepath.ToSlash(filepath.Join(year, month, fmt.Sprintf("%s_%s_%s.%s", formattedName, formattedConfidence, timestamp, fileType)))

        return clipName
}</span>

// shouldDiscardDetection checks if a detection should be discarded based on various criteria
func (p *Processor) shouldDiscardDetection(item *PendingDetection, minDetections int) (shouldDiscard bool, reason string) <span class="cov0" title="0">{
        // Check minimum detection count
        if item.Count &lt; minDetections </span><span class="cov0" title="0">{
                // Add structured logging for minimum count filtering
                GetLogger().Debug("Detection discarded due to insufficient count",
                        "species", item.Detection.Note.CommonName,
                        "count", item.Count,
                        "minimum_required", minDetections,
                        "source", p.getDisplayNameForSource(item.Source),
                        "operation", "minimum_count_filter")
                return true, fmt.Sprintf("false positive, matched %d/%d times", item.Count, minDetections)
        }</span>

        // Check privacy filter
        <span class="cov0" title="0">if p.Settings.Realtime.PrivacyFilter.Enabled </span><span class="cov0" title="0">{
                p.detectionMutex.RLock()
                lastHumanDetection, exists := p.LastHumanDetection[item.Source]
                p.detectionMutex.RUnlock()
                if exists &amp;&amp; lastHumanDetection.After(item.FirstDetected) </span><span class="cov0" title="0">{
                        // Add structured logging for privacy filter
                        GetLogger().Debug("Detection discarded by privacy filter",
                                "species", item.Detection.Note.CommonName,
                                "detection_time", item.FirstDetected,
                                "last_human_detection", lastHumanDetection,
                                "source", p.getDisplayNameForSource(item.Source),
                                "operation", "privacy_filter")
                        return true, "privacy filter"
                }</span>
        }

        // Check dog bark filter
        <span class="cov0" title="0">if p.Settings.Realtime.DogBarkFilter.Enabled </span><span class="cov0" title="0">{
                if p.Settings.Realtime.DogBarkFilter.Debug </span><span class="cov0" title="0">{
                        p.detectionMutex.RLock()
                        // Add structured logging
                        GetLogger().Debug("Last dog detection status",
                                "last_detections", p.LastDogDetection,
                                "operation", "dog_detection_debug")
                        log.Printf("Last dog detection: %s\n", p.LastDogDetection)
                        p.detectionMutex.RUnlock()
                }</span>
                <span class="cov0" title="0">p.detectionMutex.RLock()
                lastDogDetection := p.LastDogDetection[item.Source]
                p.detectionMutex.RUnlock()
                if p.CheckDogBarkFilter(item.Detection.Note.CommonName, lastDogDetection) ||
                        p.CheckDogBarkFilter(item.Detection.Note.ScientificName, lastDogDetection) </span><span class="cov0" title="0">{
                        // Add structured logging for dog bark filter
                        GetLogger().Debug("Detection discarded by dog bark filter",
                                "species", item.Detection.Note.CommonName,
                                "detection_time", item.FirstDetected,
                                "last_dog_detection", lastDogDetection,
                                "source", p.getDisplayNameForSource(item.Source),
                                "operation", "dog_bark_filter")
                        return true, "recent dog bark"
                }</span>
        }

        <span class="cov0" title="0">return false, ""</span>
}

// processApprovedDetection handles an approved detection by sending it to the worker queue
func (p *Processor) processApprovedDetection(item *PendingDetection, species string) <span class="cov0" title="0">{
        // Safely get confidence value
        var confidence float64
        if len(item.Detection.Results) &gt; 0 </span><span class="cov0" title="0">{
                confidence = float64(item.Detection.Results[0].Confidence)
        }</span>
        
        // Add structured logging
        <span class="cov0" title="0">GetLogger().Info("Approving detection",
                "species", species,
                "source", p.getDisplayNameForSource(item.Source),
                "match_count", item.Count,
                "confidence", confidence,
                "has_results", len(item.Detection.Results) &gt; 0,
                "operation", "approve_detection")
        log.Printf("Approving detection of %s from source %s, matched %d times\n",
                species, p.getDisplayNameForSource(item.Source), item.Count)

        item.Detection.Note.BeginTime = item.FirstDetected
        actionList := p.getActionsForItem(&amp;item.Detection)
        for _, action := range actionList </span><span class="cov0" title="0">{
                task := &amp;Task{Type: TaskTypeAction, Detection: item.Detection, Action: action}
                if err := p.EnqueueTask(task); err != nil </span><span class="cov0" title="0">{
                        // Check error message instead of using errors.Is to avoid import cycle
                        if err.Error() == "worker queue is full" </span><span class="cov0" title="0">{
                                // Add structured logging
                                GetLogger().Warn("Worker queue is full, dropping task",
                                        "species", species,
                                        "operation", "enqueue_task",
                                        "error", "queue_full")
                                log.Printf("❌ Worker queue is full, dropping task for %s", species)
                        }</span> else<span class="cov0" title="0"> {
                                sanitizedErr := sanitizeError(err)
                                // Add structured logging
                                GetLogger().Error("Failed to enqueue task",
                                        "error", sanitizedErr,
                                        "species", species,
                                        "operation", "enqueue_task")
                                log.Printf("Failed to enqueue task for %s: %v", species, sanitizedErr)
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }
        }

        // Update BirdNET metrics detection counter if enabled
        <span class="cov0" title="0">if p.Settings.Realtime.Telemetry.Enabled &amp;&amp; p.Metrics != nil &amp;&amp; p.Metrics.BirdNET != nil </span><span class="cov0" title="0">{
                p.Metrics.BirdNET.IncrementDetectionCounter(item.Detection.Note.CommonName)
        }</span>
}

// pendingDetectionsFlusher runs a goroutine that periodically checks the pending detections
// and flushes them to the worker queue if their deadline has passed.
func (p *Processor) pendingDetectionsFlusher() <span class="cov0" title="0">{
        // Calculate minimum detections based on overlap setting
        segmentLength := math.Max(0.1, 3.0-p.Settings.BirdNET.Overlap)
        minDetections := int(math.Max(1, 3/segmentLength))

        // Add structured logging for pending detections flusher startup
        GetLogger().Info("Starting pending detections flusher",
                "min_detections", minDetections,
                "flush_interval_seconds", 1,
                "operation", "pending_flusher_startup")

        go func() </span><span class="cov0" title="0">{
                ticker := time.NewTicker(1 * time.Second)
                defer ticker.Stop()

                for </span><span class="cov0" title="0">{
                        &lt;-ticker.C
                        now := time.Now()

                        p.pendingMutex.Lock()
                        pendingCount := len(p.pendingDetections)
                        flushableCount := 0
                        for species := range p.pendingDetections </span><span class="cov0" title="0">{
                                item := p.pendingDetections[species]
                                if now.After(item.FlushDeadline) </span><span class="cov0" title="0">{
                                        flushableCount++
                                        if shouldDiscard, reason := p.shouldDiscardDetection(&amp;item, minDetections); shouldDiscard </span><span class="cov0" title="0">{
                                                // Add structured logging
                                        GetLogger().Info("Discarding detection",
                                                "species", species,
                                                "source", p.getDisplayNameForSource(item.Source),
                                                "reason", reason,
                                                "count", item.Count,
                                                "operation", "discard_detection")
                                        log.Printf("Discarding detection of %s from source %s due to %s\n",
                                                        species, p.getDisplayNameForSource(item.Source), reason)
                                                delete(p.pendingDetections, species)
                                                continue</span>
                                        }

                                        <span class="cov0" title="0">p.processApprovedDetection(&amp;item, species)
                                        delete(p.pendingDetections, species)</span>
                                }
                        }
                        // Add structured logging for flusher activity (only when there's activity)
                        <span class="cov0" title="0">if pendingCount &gt; 0 || flushableCount &gt; 0 </span><span class="cov0" title="0">{
                                GetLogger().Debug("Pending detections flusher cycle",
                                        "pending_count", pendingCount,
                                        "flushable_count", flushableCount,
                                        "operation", "pending_flusher_cycle")
                        }</span>
                        <span class="cov0" title="0">p.pendingMutex.Unlock()

                        p.cleanUpDynamicThresholds()</span>
                }
        }()
}


// getActionsForItem determines the actions to be taken for a given detection.
func (p *Processor) getActionsForItem(detection *Detections) []Action <span class="cov0" title="0">{
        speciesName := strings.ToLower(detection.Note.CommonName)

        // Check if species has custom configuration
        if speciesConfig, exists := p.Settings.Realtime.Species.Config[speciesName]; exists </span><span class="cov0" title="0">{
                if p.Settings.Debug </span><span class="cov0" title="0">{
                        // Add structured logging
                        GetLogger().Debug("Species config exists for custom actions",
                                "species", speciesName,
                                "operation", "custom_action_check")
                        log.Println("Species config exists for custom actions")
                }</span>

                <span class="cov0" title="0">var actions []Action
                var executeDefaults bool

                // Add custom actions from the new structure
                for _, actionConfig := range speciesConfig.Actions </span><span class="cov0" title="0">{
                        switch actionConfig.Type </span>{
                        case "ExecuteCommand":<span class="cov0" title="0">
                                if len(actionConfig.Parameters) &gt; 0 </span><span class="cov0" title="0">{
                                        actions = append(actions, &amp;ExecuteCommandAction{
                                                Command: actionConfig.Command,
                                                Params:  parseCommandParams(actionConfig.Parameters, detection),
                                        })
                                }</span>
                        case "SendNotification":<span class="cov0" title="0"></span>
                                // Add notification action handling
                                // ... implementation ...
                        }
                        // If any action has ExecuteDefaults set to true, we'll include default actions
                        <span class="cov0" title="0">if actionConfig.ExecuteDefaults </span><span class="cov0" title="0">{
                                executeDefaults = true
                        }</span>
                }

                // If there are custom actions, return only those unless executeDefaults is true
                <span class="cov0" title="0">if len(actions) &gt; 0 &amp;&amp; !executeDefaults </span><span class="cov0" title="0">{
                        return actions
                }</span>

                // If executeDefaults is true, combine custom and default actions
                <span class="cov0" title="0">if len(actions) &gt; 0 &amp;&amp; executeDefaults </span><span class="cov0" title="0">{
                        defaultActions := p.getDefaultActions(detection)
                        return append(actions, defaultActions...)
                }</span>
        }

        // Fall back to default actions if no custom actions or if custom actions should be combined
        <span class="cov0" title="0">defaultActions := p.getDefaultActions(detection)
        // Add structured logging for default actions
        GetLogger().Debug("Using default actions for detection",
                "species", strings.ToLower(detection.Note.CommonName),
                "actions_count", len(defaultActions),
                "operation", "get_default_actions")
        return defaultActions</span>
}

// Helper function to parse command parameters
func parseCommandParams(params []string, detection *Detections) map[string]interface{} <span class="cov0" title="0">{
        commandParams := make(map[string]interface{})
        for _, param := range params </span><span class="cov0" title="0">{
                value := getNoteValueByName(&amp;detection.Note, param)
                // Check if the parameter is confidence and normalize it
                if param == "confidence" </span><span class="cov0" title="0">{
                        if confidence, ok := value.(float64); ok </span><span class="cov0" title="0">{
                                value = confidence * 100
                        }</span>
                }
                <span class="cov0" title="0">commandParams[param] = value</span>
        }
        <span class="cov0" title="0">return commandParams</span>
}

// getDefaultActions returns the default actions to be taken for a given detection.
func (p *Processor) getDefaultActions(detection *Detections) []Action <span class="cov0" title="0">{
        var actions []Action
        var databaseAction *DatabaseAction
        var sseAction *SSEAction

        // Append various default actions based on the application settings
        if p.Settings.Realtime.Log.Enabled </span><span class="cov0" title="0">{
                actions = append(actions, &amp;LogAction{Settings: p.Settings, EventTracker: p.GetEventTracker(), Note: detection.Note})
        }</span>

        // Create DatabaseAction if database is enabled
        <span class="cov0" title="0">if p.Settings.Output.SQLite.Enabled || p.Settings.Output.MySQL.Enabled </span><span class="cov0" title="0">{
                p.speciesTrackerMu.RLock()
                tracker := p.NewSpeciesTracker
                p.speciesTrackerMu.RUnlock()

                databaseAction = &amp;DatabaseAction{
                        Settings:          p.Settings,
                        EventTracker:      p.GetEventTracker(),
                        NewSpeciesTracker: tracker,
                        processor:         p, // Add processor reference for source name resolution
                        Note:              detection.Note,
                        Results:           detection.Results,
                        Ds:                p.Ds,
                }
        }</span>

        // Create SSE action if broadcaster is available (enabled when SSE API is configured)
        <span class="cov0" title="0">if sseBroadcaster := p.GetSSEBroadcaster(); sseBroadcaster != nil </span><span class="cov0" title="0">{
                // Create SSE retry config - use sensible defaults since SSE should be reliable
                sseRetryConfig := jobqueue.RetryConfig{
                        Enabled:      true, // Enable retries for SSE to improve reliability
                        MaxRetries:   3,    // Conservative retry count for real-time streaming
                        InitialDelay: 1 * time.Second,
                        MaxDelay:     5 * time.Second,
                        Multiplier:   2.0,
                }

                sseAction = &amp;SSEAction{
                        Settings:       p.Settings,
                        Note:           detection.Note,
                        BirdImageCache: p.BirdImageCache,
                        EventTracker:   p.GetEventTracker(),
                        RetryConfig:    sseRetryConfig,
                        SSEBroadcaster: sseBroadcaster,
                        Ds:             p.Ds,
                }
        }</span>

        // CRITICAL FIX for GitHub issue #1158: Race condition between DatabaseAction and SSEAction
        //
        // Problem: When both database and SSE are enabled, they execute concurrently via the job queue.
        // SSEAction polls for database records that haven't been saved yet, causing timeout errors:
        //   - "database ID not assigned for Eastern Wood-Pewee after 10s timeout"
        //   - "note not found in database"
        //   - "audio file ... not ready after 5s timeout"
        //
        // Solution: Combine DatabaseAction and SSEAction into a CompositeAction that executes them
        // sequentially. This ensures the database save completes before SSE attempts to broadcast,
        // eliminating the race condition while maintaining all other actions' concurrent execution.
        //
        // This is particularly important on resource-constrained hardware (e.g., Raspberry Pi with
        // SD cards) where database writes can take several seconds to complete.
        <span class="cov0" title="0">if databaseAction != nil &amp;&amp; sseAction != nil </span><span class="cov0" title="0">{
                // Create composite action for sequential execution
                compositeAction := &amp;CompositeAction{
                        Actions: []Action{databaseAction, sseAction},
                        Description: "Database save and SSE broadcast (sequential)",
                }
                actions = append(actions, compositeAction)
        }</span> else<span class="cov0" title="0"> {
                // Add them individually if only one is enabled
                if databaseAction != nil </span><span class="cov0" title="0">{
                        actions = append(actions, databaseAction)
                }</span>
                <span class="cov0" title="0">if sseAction != nil </span><span class="cov0" title="0">{
                        actions = append(actions, sseAction)
                }</span>
        }

        // Add BirdWeatherAction if enabled and client is initialized
        <span class="cov0" title="0">if p.Settings.Realtime.Birdweather.Enabled </span><span class="cov0" title="0">{
                bwClient := p.GetBwClient() // Use getter for thread safety
                if bwClient != nil </span><span class="cov0" title="0">{
                        // Create BirdWeather retry config from settings
                        bwRetryConfig := jobqueue.RetryConfig{
                                Enabled:      p.Settings.Realtime.Birdweather.RetrySettings.Enabled,
                                MaxRetries:   p.Settings.Realtime.Birdweather.RetrySettings.MaxRetries,
                                InitialDelay: time.Duration(p.Settings.Realtime.Birdweather.RetrySettings.InitialDelay) * time.Second,
                                MaxDelay:     time.Duration(p.Settings.Realtime.Birdweather.RetrySettings.MaxDelay) * time.Second,
                                Multiplier:   p.Settings.Realtime.Birdweather.RetrySettings.BackoffMultiplier,
                        }

                        actions = append(actions, &amp;BirdWeatherAction{
                                Settings:     p.Settings,
                                EventTracker: p.GetEventTracker(),
                                BwClient:     bwClient,
                                Note:         detection.Note,
                                pcmData:      detection.pcmData3s,
                                RetryConfig:  bwRetryConfig,
                        })
                }</span>
        }

        // Add MQTT action if enabled and client is available
        <span class="cov0" title="0">if p.Settings.Realtime.MQTT.Enabled </span><span class="cov0" title="0">{
                mqttClient := p.GetMQTTClient()
                if mqttClient != nil &amp;&amp; mqttClient.IsConnected() </span><span class="cov0" title="0">{
                        // Create MQTT retry config from settings
                        mqttRetryConfig := jobqueue.RetryConfig{
                                Enabled:      p.Settings.Realtime.MQTT.RetrySettings.Enabled,
                                MaxRetries:   p.Settings.Realtime.MQTT.RetrySettings.MaxRetries,
                                InitialDelay: time.Duration(p.Settings.Realtime.MQTT.RetrySettings.InitialDelay) * time.Second,
                                MaxDelay:     time.Duration(p.Settings.Realtime.MQTT.RetrySettings.MaxDelay) * time.Second,
                                Multiplier:   p.Settings.Realtime.MQTT.RetrySettings.BackoffMultiplier,
                        }

                        actions = append(actions, &amp;MqttAction{
                                Settings:       p.Settings,
                                MqttClient:     mqttClient,
                                EventTracker:   p.GetEventTracker(),
                                Note:           detection.Note,
                                BirdImageCache: p.BirdImageCache,
                                RetryConfig:    mqttRetryConfig,
                        })
                }</span>
        }

        // Check if UpdateRangeFilterAction needs to be executed for the day
        <span class="cov0" title="0">today := time.Now().Truncate(24 * time.Hour) // Current date with time set to midnight
        if p.Settings.BirdNET.RangeFilter.LastUpdated.Before(today) </span><span class="cov0" title="0">{
                // Add structured logging
                GetLogger().Info("Updating species range filter",
                        "last_updated", p.Settings.BirdNET.RangeFilter.LastUpdated,
                        "today", today,
                        "operation", "update_range_filter")
                fmt.Println("Updating species range filter")
                // Add UpdateRangeFilterAction if it hasn't been executed today
                actions = append(actions, &amp;UpdateRangeFilterAction{
                        Bn:       p.Bn,
                        Settings: p.Settings,
                })
        }</span>

        <span class="cov0" title="0">return actions</span>
}

// GetBwClient safely returns the current BirdWeather client
func (p *Processor) GetBwClient() *birdweather.BwClient <span class="cov0" title="0">{
        p.bwClientMutex.RLock()
        defer p.bwClientMutex.RUnlock()
        return p.BwClient
}</span>

// SetBwClient safely sets a new BirdWeather client
func (p *Processor) SetBwClient(client *birdweather.BwClient) <span class="cov0" title="0">{
        p.bwClientMutex.Lock()
        defer p.bwClientMutex.Unlock()
        p.BwClient = client
}</span>

// DisconnectBwClient safely disconnects and removes the BirdWeather client
func (p *Processor) DisconnectBwClient() <span class="cov0" title="0">{
        p.bwClientMutex.Lock()
        defer p.bwClientMutex.Unlock()
        // Call the Close method if the client exists
        if p.BwClient != nil </span><span class="cov0" title="0">{
                p.BwClient.Close()
                p.BwClient = nil
        }</span>
}

// SetEventTracker safely replaces the current EventTracker
func (p *Processor) SetEventTracker(tracker *EventTracker) <span class="cov0" title="0">{
        p.eventTrackerMu.Lock()
        defer p.eventTrackerMu.Unlock()
        p.EventTracker = tracker
}</span>

// GetEventTracker safely returns the current EventTracker
func (p *Processor) GetEventTracker() *EventTracker <span class="cov0" title="0">{
        p.eventTrackerMu.RLock()
        defer p.eventTrackerMu.RUnlock()
        return p.EventTracker
}</span>

// GetJobQueueStats returns statistics about the job queue
// This method is thread-safe as it delegates to JobQueue.GetStats() which handles locking internally
func (p *Processor) GetJobQueueStats() jobqueue.JobStatsSnapshot <span class="cov0" title="0">{
        return p.JobQueue.GetStats()
}</span>

// GetBn returns the BirdNET instance
// Deprecated: Use GetBirdNET instead
func (p *Processor) GetBn() *birdnet.BirdNET <span class="cov0" title="0">{
        return p.Bn
}</span>

// GetBirdNET returns the BirdNET instance
func (p *Processor) GetBirdNET() *birdnet.BirdNET <span class="cov0" title="0">{
        return p.Bn
}</span>

// SetSSEBroadcaster safely sets the SSE broadcaster function
func (p *Processor) SetSSEBroadcaster(broadcaster func(note *datastore.Note, birdImage *imageprovider.BirdImage) error) <span class="cov0" title="0">{
        p.sseBroadcasterMutex.Lock()
        defer p.sseBroadcasterMutex.Unlock()
        p.SSEBroadcaster = broadcaster
}</span>

// GetSSEBroadcaster safely returns the current SSE broadcaster function
func (p *Processor) GetSSEBroadcaster() func(note *datastore.Note, birdImage *imageprovider.BirdImage) error <span class="cov0" title="0">{
        p.sseBroadcasterMutex.RLock()
        defer p.sseBroadcasterMutex.RUnlock()
        return p.SSEBroadcaster
}</span>

// SetBackupManager safely sets the backup manager
func (p *Processor) SetBackupManager(manager interface{}) <span class="cov0" title="0">{
        p.backupMutex.Lock()
        defer p.backupMutex.Unlock()
        p.backupManager = manager
}</span>

// GetBackupManager safely returns the backup manager
func (p *Processor) GetBackupManager() interface{} <span class="cov0" title="0">{
        p.backupMutex.RLock()
        defer p.backupMutex.RUnlock()
        return p.backupManager
}</span>

// SetBackupScheduler safely sets the backup scheduler
func (p *Processor) SetBackupScheduler(scheduler interface{}) <span class="cov0" title="0">{
        p.backupMutex.Lock()
        defer p.backupMutex.Unlock()
        p.backupScheduler = scheduler
}</span>

// GetBackupScheduler safely returns the backup scheduler
func (p *Processor) GetBackupScheduler() interface{} <span class="cov0" title="0">{
        p.backupMutex.RLock()
        defer p.backupMutex.RUnlock()
        return p.backupScheduler
}</span>

// CleanupLogDeduplicator removes stale log deduplication entries to prevent memory growth.
// Returns the number of entries removed.
func (p *Processor) CleanupLogDeduplicator(staleAfter time.Duration) int <span class="cov0" title="0">{
        if p.logDedup == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">removed := p.logDedup.Cleanup(staleAfter)
        if removed &gt; 0 </span><span class="cov0" title="0">{
                GetLogger().Debug("Cleaned stale log deduplication entries",
                        "removed_count", removed,
                        "stale_after", staleAfter,
                        "operation", "log_dedup_cleanup")
        }</span>
        <span class="cov0" title="0">return removed</span>
}

// getDisplayNameForSource converts a source ID to user-friendly DisplayName
// Falls back to sanitized source if lookup fails (prevents credential exposure)
// TODO: Consider moving to AudioSource struct throughout the pipeline to eliminate this lookup
func (p *Processor) getDisplayNameForSource(sourceID string) string <span class="cov0" title="0">{
        registry := myaudio.GetRegistry()
        if registry != nil </span><span class="cov0" title="0">{
                // Try lookup by ID first
                if source, exists := registry.GetSourceByID(sourceID); exists </span><span class="cov0" title="0">{
                        return source.DisplayName
                }</span>
                
                // Try lookup by connection string (handles legacy case)
                <span class="cov0" title="0">if source, exists := registry.GetSourceByConnection(sourceID); exists </span><span class="cov0" title="0">{
                        return source.DisplayName
                }</span>
        }
        
        // Fallback: sanitize the source to prevent credential exposure in logs
        // This handles cases where sourceID might be a raw RTSP URL
        <span class="cov0" title="0">return privacy.SanitizeRTSPUrl(sourceID)</span>
}

// Shutdown gracefully stops all processor components
func (p *Processor) Shutdown() error <span class="cov0" title="0">{
        // Cancel all worker goroutines
        if p.workerCancel != nil </span><span class="cov0" title="0">{
                p.workerCancel()
        }</span>

        // Stop the job queue with a timeout
        <span class="cov0" title="0">if err := p.JobQueue.StopWithTimeout(30 * time.Second); err != nil </span><span class="cov0" title="0">{
                // Add structured logging
                GetLogger().Warn("Job queue shutdown timed out",
                        "error", err,
                        "timeout_seconds", 30,
                        "operation", "job_queue_shutdown")
                log.Printf("Warning: job queue shutdown timed out: %v", err)
        }</span>

        // Disconnect BirdWeather client
        <span class="cov0" title="0">p.DisconnectBwClient()

        // Disconnect MQTT client if connected
        mqttClient := p.GetMQTTClient()
        if mqttClient != nil &amp;&amp; mqttClient.IsConnected() </span><span class="cov0" title="0">{
                mqttClient.Disconnect()
        }</span>

        // Close the species tracker to release resources
        <span class="cov0" title="0">p.speciesTrackerMu.RLock()
        tracker := p.NewSpeciesTracker
        p.speciesTrackerMu.RUnlock()
        
        if tracker != nil </span><span class="cov0" title="0">{
                if err := tracker.Close(); err != nil </span><span class="cov0" title="0">{
                        // Add structured logging
                        GetLogger().Warn("Failed to close species tracker",
                                "error", err,
                                "operation", "species_tracker_cleanup")
                        log.Printf("Warning: failed to close species tracker: %v", err)
                }</span>
        }

        // Add structured logging
        <span class="cov0" title="0">GetLogger().Info("Processor shutdown complete",
                "operation", "processor_shutdown")
        log.Println("Processor shutdown complete")
        return nil</span>
}

// NewWithSpeciesInfo creates a new observation note with pre-parsed species information
// This ensures that the species code from the taxonomy lookup is preserved
func (p *Processor) NewWithSpeciesInfo(
        beginTime, endTime time.Time,
        scientificName, commonName, speciesCode string,
        confidence float64,
        source, clipName string,
        elapsedTime time.Duration) datastore.Note <span class="cov0" title="0">{

        // detectionTime is time now minus 3 seconds to account for the delay in the detection
        now := time.Now()
        date := now.Format("2006-01-02")
        detectionTime := now.Add(-2 * time.Second)
        timeStr := detectionTime.Format("15:04:05")

        var sourceStruct datastore.AudioSource
        if p.Settings.Input.Path != "" </span><span class="cov0" title="0">{
                // For file input, create simple source struct
                sourceStruct = datastore.AudioSource{
                        ID:          source, // Use original source as ID for file operations
                        SafeString:  p.Settings.Input.Path,
                        DisplayName: filepath.Base(p.Settings.Input.Path),
                }
        }</span> else<span class="cov0" title="0"> {
                // Use registry to get proper AudioSource struct with ID, SafeString, and DisplayName
                registry := myaudio.GetRegistry()
                if registry != nil </span><span class="cov0" title="0">{
                        // Try to get existing source by connection string
                        if existingSource, exists := registry.GetSourceByConnection(source); exists </span><span class="cov0" title="0">{
                                sourceStruct = datastore.AudioSource{
                                        ID:          existingSource.ID,          // Use source ID for buffer operations
                                        SafeString:  existingSource.SafeString,  // Use sanitized string for logging
                                        DisplayName: existingSource.DisplayName, // Use display name for UI
                                }
                        }</span> else<span class="cov0" title="0"> {
                                // Try to get by ID directly
                                if registrySource, exists := registry.GetSourceByID(source); exists </span><span class="cov0" title="0">{
                                        sourceStruct = datastore.AudioSource{
                                                ID:          registrySource.ID,
                                                SafeString:  registrySource.SafeString,
                                                DisplayName: registrySource.DisplayName,
                                        }
                                }</span> else<span class="cov0" title="0"> {
                                        // Last resort: create struct with manual sanitization for safety
                                        sourceStruct = datastore.AudioSource{
                                                ID:          source,                           // Use original as ID
                                                SafeString:  privacy.SanitizeRTSPUrl(source), // Sanitize for logging
                                                DisplayName: privacy.SanitizeRTSPUrl(source), // Use same for display
                                        }
                                }</span>
                        }
                } else<span class="cov0" title="0"> {
                        // Fallback when registry not available
                        sourceStruct = datastore.AudioSource{
                                ID:          source,                           // Use original as ID
                                SafeString:  privacy.SanitizeRTSPUrl(source), // Sanitize for logging
                                DisplayName: privacy.SanitizeRTSPUrl(source), // Use same for display
                        }
                }</span>
        }

        // Round confidence to two decimal places
        <span class="cov0" title="0">roundedConfidence := math.Round(confidence*100) / 100

        // Return a new Note struct populated with the provided parameters and the current date and time
        return datastore.Note{
                SourceNode:     p.Settings.Main.Name,           // From the provided configuration settings
                Date:           date,                           // Use ISO 8601 date format
                Time:           timeStr,                        // Use 24-hour time format
                Source:         sourceStruct,                   // Proper AudioSource struct with ID, SafeString, DisplayName
                BeginTime:      beginTime,                      // Start time of the observation
                EndTime:        endTime,                        // End time of the observation
                SpeciesCode:    speciesCode,                    // Species code from taxonomy lookup
                ScientificName: scientificName,                 // Scientific name from taxonomy lookup
                CommonName:     commonName,                     // Common name from taxonomy lookup
                Confidence:     roundedConfidence,              // Confidence score of the observation
                Latitude:       p.Settings.BirdNET.Latitude,    // Geographic latitude where the observation was made
                Longitude:      p.Settings.BirdNET.Longitude,   // Geographic longitude where the observation was made
                Threshold:      p.Settings.BirdNET.Threshold,   // Threshold setting from configuration
                Sensitivity:    p.Settings.BirdNET.Sensitivity, // Sensitivity setting from configuration
                ClipName:       clipName,                       // Name of the audio clip
                ProcessingTime: elapsedTime,                    // Time taken to process the observation
        }</span>
}

// logDetectionResults logs detection processing results using the LogDeduplicator
// to prevent repetitive logging while maintaining observability.
func (p *Processor) logDetectionResults(source string, rawCount, filteredCount int) <span class="cov0" title="0">{
        // Use the LogDeduplicator to determine if we should log
        shouldLog, reason := p.logDedup.ShouldLog(source, rawCount, filteredCount)
        
        if shouldLog </span><span class="cov0" title="0">{
                GetLogger().Info("Detection processing results",
                        "source", p.getDisplayNameForSource(source),
                        "raw_results_count", rawCount,
                        "filtered_detections_count", filteredCount,
                        "log_reason", reason,
                        "operation", "process_detections_summary")
        }</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package processor

import (
        "github.com/stretchr/testify/mock"
        "github.com/tphakala/birdnet-go/internal/datastore"
)

// MockSpeciesDatastore implements the SpeciesDatastore interface using testify/mock
type MockSpeciesDatastore struct {
        mock.Mock
}

// GetNewSpeciesDetections implements the SpeciesDatastore interface method using testify/mock
func (m *MockSpeciesDatastore) GetNewSpeciesDetections(startDate, endDate string, limit, offset int) ([]datastore.NewSpeciesData, error) <span class="cov8" title="1">{
        args := m.Called(startDate, endDate, limit, offset)
        return safeSlice[datastore.NewSpeciesData](args, 0), args.Error(1)
}</span>

// GetSpeciesFirstDetectionInPeriod implements the SpeciesDatastore interface method using testify/mock
func (m *MockSpeciesDatastore) GetSpeciesFirstDetectionInPeriod(startDate, endDate string, limit, offset int) ([]datastore.NewSpeciesData, error) <span class="cov8" title="1">{
        args := m.Called(startDate, endDate, limit, offset)
        return safeSlice[datastore.NewSpeciesData](args, 0), args.Error(1)
}</span>

// safeSlice is a helper for mock methods returning slices.
// It safely handles nil arguments and performs type assertion.
// TODO: Move to a shared test utilities package to reduce duplication
func safeSlice[T any](args mock.Arguments, index int) []T <span class="cov8" title="1">{
        if arg := args.Get(index); arg != nil </span><span class="cov8" title="1">{
                if slice, ok := arg.([]T); ok </span><span class="cov8" title="1">{
                        return slice
                }</span>
                <span class="cov0" title="0">panic("safeSlice: type assertion failed")</span>
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">// workers.go contains task processing logic for the processor.
package processor

import (
        "context"
        "regexp"
        "time"

        "github.com/tphakala/birdnet-go/internal/analysis/jobqueue"
        "github.com/tphakala/birdnet-go/internal/errors"
)

// TaskType defines types of tasks that can be handled by the worker.
type TaskType int

const (
        TaskTypeAction TaskType = iota // Represents an action task type
)

// Timing constants for operations
const (
        // DefaultEnqueueTimeout is the default timeout for task enqueue operations
        DefaultEnqueueTimeout = 5 * time.Second
)

// Sentinel errors for processor operations
var (
        ErrNilTask = errors.Newf("cannot enqueue nil task").
                Component("analysis.processor").
                Category(errors.CategoryValidation).
                Build()
        
        ErrNilAction = errors.Newf("cannot enqueue task with nil action").
                Component("analysis.processor").
                Category(errors.CategoryValidation).
                Build()
)

// Task represents a unit of work, encapsulating the detection and the action to be performed.
type Task struct {
        Type      TaskType
        Detection Detections
        Action    Action
}

// Variable used for testing to override retry configuration
var testRetryConfigOverride func(action Action) (jobqueue.RetryConfig, bool)

// startWorkerPool initializes the job queue for task processing.
// This is kept for backward compatibility but now simply ensures the job queue is started.
func (p *Processor) startWorkerPool() <span class="cov0" title="0">{
        // Performance metrics logging pattern
        logger := GetLogger()
        startTime := time.Now()
        defer func() </span><span class="cov0" title="0">{
                logger.Debug("Worker pool initialization completed",
                        "duration_ms", time.Since(startTime).Milliseconds(),
                        "max_capacity", p.JobQueue.GetMaxJobs(),
                        "component", "analysis.processor",
                        "operation", "worker_pool_start")
        }</span>()

        // State transition logging pattern
        <span class="cov0" title="0">logger.Info("Starting worker pool",
                "max_capacity", p.JobQueue.GetMaxJobs(),
                "component", "analysis.processor")

        // Create a cancellable context for the job queue
        ctx, cancel := context.WithCancel(context.Background())

        // Store the cancel function in the processor for clean shutdown
        p.workerCancel = cancel

        // Ensure the job queue is started with our context
        p.JobQueue.StartWithContext(ctx)

        // State transition logging - final state
        logger.Info("Worker pool started successfully",
                "max_capacity", p.JobQueue.GetMaxJobs(),
                "component", "analysis.processor",
                "operation", "worker_pool_start")</span>
}

// Pre-compiled regex patterns for performance
var (
        // URL credential patterns
        rtspRegex = regexp.MustCompile(`(?i)rtsp://[^:]+:[^@]+@`)
        mqttRegex = regexp.MustCompile(`(?i)mqtt://[^:]+:[^@]+@`)
        
        // Security token patterns  
        apiKeyRegex = regexp.MustCompile(`(?i)(api[_-]?key|apikey|token|secret)[=:]["']?[a-zA-Z0-9_\-\.]{5,}["']?`)
        passwordRegex = regexp.MustCompile(`(?i)(password|passwd|pwd)[=:]["']?[^&amp;"'\s]+["']?`)
        oauthRegex = regexp.MustCompile(`(?i)(Bearer|OAuth|oauth_token|access_token)[\s=:]["']?[^&amp;"'\s]+["']?`)
        otherSensitiveRegex = regexp.MustCompile(`(?i)(private|sensitive|credential|auth)[=:]["']?[^&amp;"'\s]+["']?`)
)

// getJobQueueRetryConfig extracts the retry configuration from an action
func getJobQueueRetryConfig(action Action) jobqueue.RetryConfig <span class="cov0" title="0">{
        // Check if we have a test override (defined in workers_test.go)
        if testRetryConfigOverride != nil </span><span class="cov0" title="0">{
                if config, ok := testRetryConfigOverride(action); ok </span><span class="cov0" title="0">{
                        return config
                }</span>
        }

        <span class="cov0" title="0">switch a := action.(type) </span>{
        case *BirdWeatherAction:<span class="cov0" title="0">
                return a.RetryConfig</span> // Now directly returns jobqueue.RetryConfig
        case *MqttAction:<span class="cov0" title="0">
                return a.RetryConfig</span> // Now directly returns jobqueue.RetryConfig
        default:<span class="cov0" title="0">
                // Default no retry for actions that don't support it
                return jobqueue.RetryConfig{Enabled: false}</span>
        }
}

// sanitizeString applies sanitization rules to remove sensitive information from strings
// Uses pre-compiled regex patterns for better performance
func sanitizeString(input string) string <span class="cov0" title="0">{
        // Apply sanitization rules in order
        result := rtspRegex.ReplaceAllString(input, "rtsp://[redacted]@")
        result = mqttRegex.ReplaceAllString(result, "mqtt://[redacted]@")
        result = apiKeyRegex.ReplaceAllString(result, "$1=[REDACTED]")
        result = passwordRegex.ReplaceAllString(result, "$1=[REDACTED]")
        result = oauthRegex.ReplaceAllString(result, "$1 [REDACTED]")
        result = otherSensitiveRegex.ReplaceAllString(result, "$1=[REDACTED]")
        
        return result
}</span>

// SanitizedError is a custom error type that wraps the original error while sanitizing its message
type SanitizedError struct {
        original     error
        sanitizedMsg string
}

// Error returns the sanitized error message
func (e *SanitizedError) Error() string <span class="cov0" title="0">{
        return e.sanitizedMsg
}</span>

// Unwrap returns the original error, allowing errors.Is() and errors.As() to work with the sanitized error
func (e *SanitizedError) Unwrap() error <span class="cov0" title="0">{
        return e.original
}</span>

// sanitizeError removes sensitive information from error messages
func sanitizeError(err error) error <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Return a new SanitizedError that wraps the original error
        <span class="cov0" title="0">return &amp;SanitizedError{
                original:     err,
                sanitizedMsg: sanitizeString(err.Error()),
        }</span>
}

// sanitizeActionType removes sensitive information from action type strings
func sanitizeActionType(actionType string) string <span class="cov0" title="0">{
        return sanitizeString(actionType)
}</span>

// EnqueueTask adds a task directly to the job queue for processing.
// Uses context.Background() for backward compatibility.
func (p *Processor) EnqueueTask(task *Task) error <span class="cov0" title="0">{
        return p.EnqueueTaskCtx(context.Background(), task)
}</span>

// EnqueueTaskCtx adds a task directly to the job queue for processing with context.
//
// This method respects the provided context for cancellation and timeouts.
// If the context does not have a deadline, a default timeout of 
// DefaultEnqueueTimeout (5 seconds) is automatically applied to prevent
// indefinite blocking during enqueue operations.
//
// Context behavior:
//   - If ctx is already cancelled, returns immediately with cancellation error
//   - If ctx has a deadline, uses it as-is
//   - If ctx has no deadline, wraps with DefaultEnqueueTimeout
//
// Parameters:
//   - ctx: Context for cancellation and timeout control
//   - task: Task to enqueue (must not be nil, with non-nil Action)
//
// Returns error if:
//   - Context is cancelled
//   - Task or Task.Action is nil
//   - Job queue is full or stopped
//   - Enqueue operation fails
func (p *Processor) EnqueueTaskCtx(ctx context.Context, task *Task) error <span class="cov0" title="0">{
        // Check if context is already cancelled before starting
        if ctx.Err() != nil </span><span class="cov0" title="0">{
                return errors.Newf("task enqueue cancelled: %w", ctx.Err()).
                        Component("analysis.processor").
                        Category(errors.CategoryCancellation).
                        Context("operation", "enqueue_task").
                        Context("cancelled_before_start", true).
                        Context("retryable", false).
                        Build()
        }</span>

        // Performance metrics logging pattern
        <span class="cov0" title="0">logger := GetLogger()
        startTime := time.Now()
        defer func() </span><span class="cov0" title="0">{
                logger.Debug("Task enqueue operation completed",
                        "duration_ms", time.Since(startTime).Milliseconds(),
                        "component", "analysis.processor",
                        "operation", "enqueue_task")
        }</span>()

        // Add timeout if context doesn't have one
        <span class="cov0" title="0">if _, hasDeadline := ctx.Deadline(); !hasDeadline </span><span class="cov0" title="0">{
                var cancel context.CancelFunc
                ctx, cancel = context.WithTimeout(ctx, DefaultEnqueueTimeout)
                defer cancel()
        }</span>

        // Validate task parameter
        <span class="cov0" title="0">if task == nil </span><span class="cov0" title="0">{
                return errors.New(ErrNilTask).
                        Component("analysis.processor").
                        Category(errors.CategoryValidation).
                        Context("operation", "enqueue_task").
                        Context("validation_type", "nil_task").
                        Context("retryable", false).
                        Build()
        }</span>

        // Validate the task action
        <span class="cov0" title="0">if task.Action == nil </span><span class="cov0" title="0">{
                return errors.New(ErrNilAction).
                        Component("analysis.processor").
                        Category(errors.CategoryValidation).
                        Context("operation", "enqueue_task").
                        Context("validation_type", "nil_action").
                        Context("retryable", false).
                        Build()
        }</span>

        // Get action description for logging and error context
        <span class="cov0" title="0">actionDesc := task.Action.GetDescription()
        sanitizedDesc := sanitizeString(actionDesc)
        
        // Get species name for enhanced context
        speciesName := "unknown"
        if task.Detection.Note.CommonName != "" </span><span class="cov0" title="0">{
                speciesName = task.Detection.Note.CommonName
        }</span>

        // Get retry configuration for the action
        <span class="cov0" title="0">jqRetryConfig := getJobQueueRetryConfig(task.Action)

        // State transition logging - task received
        if p.Settings.Debug </span><span class="cov0" title="0">{
                logger.Debug("Task received for enqueueing",
                        "task_description", sanitizedDesc,
                        "species", speciesName,
                        "retry_enabled", jqRetryConfig.Enabled,
                        "max_retries", jqRetryConfig.MaxRetries,
                        "component", "analysis.processor")
        }</span>

        // Enqueue the task to the job queue using provided context
        <span class="cov0" title="0">job, err := p.JobQueue.Enqueue(ctx, &amp;ActionAdapter{action: task.Action}, task.Detection, jqRetryConfig)
        if err != nil </span><span class="cov0" title="0">{
                // Enhanced error handling with specific context using sentinel errors
                switch </span>{
                case errors.Is(err, jobqueue.ErrQueueFull):<span class="cov0" title="0">
                        queueSize := p.JobQueue.GetMaxJobs()
                        
                        // Enhanced queue full error
                        enhancedErr := errors.Newf("job queue is full (capacity: %d): %w", queueSize, err).
                                Component("analysis.processor").
                                Category(errors.CategoryWorker).
                                Context("operation", "enqueue_task").
                                Context("error_type", "queue_full").
                                Context("queue_capacity", queueSize).
                                Context("task_description", sanitizedDesc).
                                Context("species", speciesName).
                                Context("retryable", true).
                                Build()

                        logger.Warn("Job queue is full, dropping task",
                                "queue_capacity", queueSize,
                                "task_description", sanitizedDesc,
                                "species", speciesName,
                                "component", "analysis.processor")

                        return enhancedErr</span>

                case errors.Is(err, jobqueue.ErrQueueStopped):<span class="cov0" title="0">
                        // Enhanced queue stopped error
                        enhancedErr := errors.Newf("cannot enqueue task, job queue stopped: %w", err).
                                Component("analysis.processor").
                                Category(errors.CategoryWorker).
                                Context("operation", "enqueue_task").
                                Context("error_type", "queue_stopped").
                                Context("task_description", sanitizedDesc).
                                Context("species", speciesName).
                                Context("retryable", false).
                                Build()

                        logger.Error("Cannot enqueue task, job queue has been stopped",
                                "task_description", sanitizedDesc,
                                "species", speciesName,
                                "component", "analysis.processor")

                        return enhancedErr</span>

                default:<span class="cov0" title="0">
                        // Enhanced generic enqueue error
                        enhancedErr := errors.Newf("failed to enqueue task: %w", err).
                                Component("analysis.processor").
                                Category(errors.CategoryWorker).
                                Context("operation", "enqueue_task").
                                Context("error_type", "enqueue_failure").
                                Context("task_description", sanitizedDesc).
                                Context("species", speciesName).
                                Context("retry_enabled", jqRetryConfig.Enabled).
                                Context("retryable", true).
                                Build()

                        logger.Error("Failed to enqueue task",
                                "task_description", sanitizedDesc,
                                "species", speciesName,
                                "error", sanitizeString(err.Error()),
                                "component", "analysis.processor")

                        return enhancedErr</span>
                }
        }

        // State transition logging - task successfully enqueued
        <span class="cov0" title="0">if p.Settings.Debug </span><span class="cov0" title="0">{
                logger.Debug("Task enqueued successfully",
                        "task_description", sanitizedDesc,
                        "job_id", job.ID,
                        "species", speciesName,
                        "component", "analysis.processor")
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
